<?xml version = "1.0"?>
<lesson>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Homepage/1-primitive-types.png</image>
		<title>Comments</title>
		<description>Become familiar with the three types of Java comments</description>
		<pages>
			<page>
				<text>
					This line inside the main method is a comment:
					// Display a greeting in the console window

					This comment is purely for the beneﬁt of the human reader, to explain in more detail
					what the next statement does. Any text enclosed between // and the end of the line is
					completely ignored by the compiler. Comments are used to explain the program to other
					programmers or to yourself.

					There are three kinds of comments:

					/* comment */
					// one-line-comment
					/** documentationComment */

					The one-line comment extends to the end of the line. The other comments can span
					multiple lines and extend to the */ delimiter.

					A documentation comment is delimited by /** and */. You can comment

					• Classes
					• Methods
					• Instance variables

					Each comment is placed immediately above the feature it documents. Each /** . . . */
					documentation comment contains introductory text followed by tagged documentation.
				</text>
			</page>
			<page title = "Commenting the Public Interface">
				<text>
					When you implement classes and methods, you should get into the habit of thoroughly
					commenting their behaviors. In Java there is a very useful standard form for
					documentation comments. If you use this form in your classes, a program called
					javadoc can automatically generate a neat set of HTML pages that describe them.
					A documentation comment is placed before the class or method declaration that
					is being documented. It starts with a /**, a special comment delimiter used by the
					javadoc utility. Then you describe the method’s purpose. Then, for each method
					parameter, you supply a line that starts with @param, followed by the parameter name
					and a short explanation. Finally, you supply a line that starts with @return, describing
					the return value. You omit the @param tag for methods that have no parameters,
					and you omit the @return tag for methods whose return type is void.
					The javadoc utility copies the first sentence of each comment to a summary table
					in the HTML documentation. Therefore, it is best to write that first sentence with
					some care. It should start with an uppercase letter and end with a period. It does not
					have to be a grammatically complete sentence, but it should be meaningful when it
					is pulled out of the comment and displayed in a summary.

					Here are two typical examples.
					/**

					Withdraws money from the bank account.
					@param amount the amount to withdraw
					*/
					public void withdraw(double amount)
					{

					implementation—filled in later
					}
					/**

					Gets the current balance of the bank account.
					@return the current balance
					*/
					public double getBalance()
					{

					implementation—filled in later
					}

					The comments you have just seen explain individual methods. Supply a brief comment for each
					class, explaining its purpose. The comment syntax for class comments
					is very simple: Just place the documentation comment above the class.
					/**

					A bank account has a balance that can be changed by
					deposits and withdrawals.
					*/
					public class BankAccount
					{
					. . .
					}

					Your first reaction may well be “Whoa! Am I supposed to write all this stuff?”
					These comments do seem pretty repetitive. But you should take the time to write
					them, even if it feels silly.
					It is always a good idea to write the method comment first, before writing the
					code in the method body. This is an excellent test to see that you firmly understand
					what you need to program. If you can’t explain what a class or method does, you
					aren’t ready to implement it.
					What about very simple methods? You can easily spend more time pondering
					whether a comment is too trivial to write than it takes to write it. In practical
					programming, very simple methods are rare. It is harmless to have a trivial method
					overcommented, whereas a complicated method without any comment can cause
					real grief to future maintenance programmers. According to the standard Java documentation
					style, every class, every method, every parameter, and every return
					value should have a comment.
				</text>
			</page>
			<page title = "Self Check">
				<text>
					SELF CHECK

					1. Provide documentation comments for the Counter class of Section 3.1.

					2. Suppose we enhance the BankAccount class so that each account has an account
					number. Supply a documentation comment for the constructor
					public BankAccount(int accountNumber, double initialBalance)

					3. Why is the following documentation comment questionable?

					/**
					Each account has an account number.
					@return the account number of this account
					*/
					public int getAccountNumber()
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Homepage/1-primitive-types.png</image>
		<title>Primitive Types</title>
		<description>Become familiar with basic programming terminology and learn about the concepts of types, variables, and assignment</description>
		<pages>
			<page>
				<text>
A computer program processes values: numbers, strings, and more complex data
items. In Java, every value has a TYPE. (A type speciﬁes a set of values and 
the operations that can be carried out with the values.) For example, the number 13 has the type int
(an abbreviation for “integer”), "Hello, World" has the type String, and the object
System.out has the type PrintStream. The type tells you what operations you can carry
out with the values. For example, you can compute the sum or product of any two
integers. You can call println on any object of type PrintStream.
Java has separate types for INTEGERS and FLOATING-POINT numbers. Integers are
whole numbers; floating-point numbers can have fractional parts. For example, 13
is an integer and 1.3 is a floating-point number.
The name “floating-point” describes the representation of the number in the computer as a sequence of the significant digits and an indication of the position of the
decimal point. For example, the numbers 13000.0, 1.3, 0.00013 all have the same decimal digits: 13. When a floating-point number is multiplied or divided by 10, only
the position of the decimal point changes; it “floats”. This representation is related to
the “scientific” notation 1.3 × 10^(–4). (Actually, the computer represents numbers in
base 2, not base 10, but the principle is the same.)
If you need to process numbers with a fractional part, you should use the type
called DOUBLE (The double type denotes ﬂoatingpoint numbers that can have fractional parts.), 
which stands for “double precision floating-point number”. Think of
a number in double format as any number that can appear in the display panel of a
calculator, such as 1.3 or –0.333333333.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%201/2.png</image>
			</page>
			<page>
				<text>
When a value such as 13 or 1.3 occurs in a Java program, it is called a number literal. Do not use commas when you write number literals in Java. For example,
13,000 must be written as 13000. To write numbers in exponential notation in Java,
use the notation En instead of “ × 10n ”. For example, 1.3 × 10–4 is written as 1.3E-4.
Table 1 shows how to write integer and floating-point literals in Java.
You may wonder why Java has separate integer and floating-point number types.
Pocket calculators don’t need a separate integer type; they use floating-point numbers for all calculations. However, integers have several advantages over floatingpoint numbers. They take less storage space, are processed faster, and don’t cause
rounding errors. You will want to use the int type for quantities that can never have
fractional parts, such as the length of a string. Use the double type for quantities that
can have fractional parts, such as a grade point average.
There are several other number types in Java that are not as commonly used. We
will discuss these types in Chapter 4. For most programs in this book, however, the
int and double types are all you need for processing numbers.
In Java, the number types (int, double, and the less commonly used types) are
primitive types. Numbers are not objects. The number types have no methods.
However, you can combine numbers with operators such as + and -, as in 10 + n
or n - 1. To multiply two numbers, use the * operator. For example, 10 × n is written as 10 * n.
A combination of variables, literals, operators, and/or methods (which you will
see in Section 2.4) is called an expression. A typical example of an expression is
x + y * 2.

Numbers can be combined by arithmetic operators such as +, -, and *.

As in mathematics, the * operator binds more strongly than the + operator. That is,
x + y * 2 means the sum of x and y * 2. If you want to multiply the sum of x and y
by 2, use parentheses:
(x + y) * 2
				</text>
			</page>
			<page title = "Self Check">
				<text>
Self Check

1. What are the types of the values 0 and "0"?
2. Which number type would you use for storing the area of a circle?
3. Why is the expression 13.println() an error?
4. Write an expression to compute the average of the values x and y.
				</text>
			</page>
			<page>
				<text>
In Java, every value is either a reference to an object, or it belongs to one of the eight
primitive types shown in Table 1.
Six of the primitive types are number types; four of them for integers and two for
ﬂoating-point numbers.

The largest number that can be represented in an int is denoted by Integer.MAX_VALUE. Its value is about 2.14
billion. Similarly, Integer.MIN_VALUE is the smallest integer, about –2.14 billion.
Generally, you will use the int type for integer quantities. However, occasionally,
calculations involving integers can overflow. This happens if the result of a computation exceeds the range for the number type. For example:

int n = 1000000;
System.out.println(n * n); // Prints –727379968, which is clearly wrong

The product n * n is 1012, which is larger than the largest integer (about 2 · 109). The
result is truncated to ﬁt into an int, yielding a value that is completely wrong.

Unfortunately, there is no warning when an integer overﬂow occurs.
If you run into this problem, the simplest remedy is to use the long type.

Overﬂow is not usually a problem for double-precision ﬂoating-point numbers.
The double type has a range of about ±10308 and about 15 signiﬁcant digits. However, you want to avoid the float type—it has less than 7 signiﬁcant digits. (Some
programmers use float to save on memory if they need to store a huge set of numbers that do not require much precision.)
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%201/2.png</image>
			</page>
			<page>
				<text>
Rounding errors are a more serious issue with ﬂoating-point values. Rounding
errors can occur when you convert between binary and decimal numbers, or
between integers and ﬂoating-point numbers. When a value cannot be converted
exactly, it is rounded to the nearest match. Consider this example:

double f = 4.35;
System.out.println(100 * f); // Prints 434.99999999999994

This problem is caused because computers represent numbers in the binary number
system. In the binary number system, there is no exact representation of the fraction 1/10, just as there is no exact representation of the fraction 1/3 = 0.33333 in the
decimal number system. (See Special Topic 4.2 on page 130 for more information.)
For this reason, the double type is not appropriate for ﬁnancial calculations. In
this book, we will continue to use double values for bank balances and other ﬁnancial quantities so that we keep our programs as simple as possible. However,
professional programs need to use the BigDecimal type for this purpose—see Special
Topic 4.1 on page 130.
In Java, it is legal to assign an integer value to a ﬂoating-point variable:

int dollars = 100;
double balance = dollars; // OK

But the opposite assignment is an error: You cannot assign a ﬂoating-point expression to an integer variable.

double balance = 13.75;
int dollars = balance; // Error

You will see in Section 4.3.5 how to convert a value of type double into an integer.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

5. Which are the most commonly used number types in Java?
6. Suppose you want to write a program that works with population data from
various countries. Which Java data type should you use?
7. Which of the following initializations are incorrect, and why?
a. int dollars = 100.0;
b. double balance = 100;
				</text>
			</page>
			<page>
				<text>
In Java, strings are objects that belong to the class String. (You can tell that String is
a class name because it starts with an uppercase letter. The primitive types int and
double start with lowercase letters.)
You do not need to call a constructor to create a string object. You can obtain a
string literal simply by enclosing a sequence of characters in double quotation
marks. For example, the string literal "Harry" is an object of the String class.
The number of characters in a string is called the length of the string. As you
have seen in Chapter 2, you can use the length method to obtain the length of a
string. For example, "Hello".length() is 5, and the length of "Hello, World!" is 13.
(The quotation marks are not part of the string and do not contribute to the length,
but you must count spaces and punctuation marks.)
A string of length zero, containing no characters, is called the empty string and is
written as "".
				</text>
			</page>
			<page>
				<text>
In Java, an expression such as amount &lt; 1000 has a value, just as the expression
amount + 1000 has a value. The value of a relational expression is either true or false.
For example, if amount is 500, then the value of amount &lt; 1000 is true. Try it out: The
program fragment

double amount = 0;
bool lessThanThousand = amount &lt; 1000;
System.out.println(lessThanThousand);

prints true. The values true and false are not numbers, nor are they objects of a
class. They belong to a separate type, called boolean. The Boolean type is named
after the mathematician George Boole (1815–1864), a pioneer in the study of logic.
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Homepage/2-operators.png</image>
		<title>Operators</title>
		<description>Learn how to use operators to manipulate variables. From changing the values of variables to casting variables to different types, you'll understand how to control and utilize your data</description>
		<pages>
			<page title = "Assignment Operator">
				<text>
You can change the value of a variable with the assignment operator (=). For example, consider the variable declaration

int width = 10;

If you want to change the value of the variable, simply assign the new value:

width = 20;

The assignment replaces the original value of the variable (see Figure 1).
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%202/2.png</image>
			</page>
			<page title = "Assignment Errors">
				<text>
It is an error to use a variable that has never had a value assigned to it. For example,
the following assignment statement has an error:
int height;
width = height;

// ERROR—uninitialized variable height

The compiler will complain about an “uninitialized variable” when you use a variable that has never been assigned a value. (See Figure 2.)
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%202/4.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%202/5.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%202/6.png</image>
			</page>
			<page title = "Good Assignment Practice">
				<text>
The remedy is to assign a value to the variable before you use it:
All variables must be initialized before you access them.

int height = 30;
width = height; // OK

Or, even better, initialize the variable when you declare it.
int height = 30;
int width = height; // OK

The right-hand side of the = symbol can be a mathematical expression. For example,

width = height + 10;

This means “compute the value of height + 10 and store that value in the variable
width”.
In the Java programming language, the = operator denotes an action, to replace the
value of a variable. This usage differs from the mathematical usage of the = symbol,
as a statement about equality. For example, in Java, the following statement is
entirely legal:
width = width + 10;

This means “compute the value of width + 10 (figure 3.1) and store that value in the variable
width (figure 3.2) ” 

In Java, it is not a problem that the variable width is used on both sides of the =
symbol. Of course, in mathematics, the equation width = width + 10 has no solution.


SELF CHECK
1. Is 12 = 12 a valid expression in the Java language?
2. How do you change the value of the greeting variable to "Hello, Nina!"?

Common Error: Confusing Variable Declarations and Assignment Statements

Suppose your program declares a variable as follows:
int width = 20;

If you want to change the value of the variable, you use an assignment statement:
width = 30;

It is a common error to accidentally use another variable declaration:
int width = 30; // ERROR—starts with int and is therefore a declaration

But there is already a variable named width. The compiler will complain that you are trying
to declare another variable with the same name.
				</text>
			</page>
			<page title = "Arithmetic Operators">
				<text>
Java supports the same four basic arithmetic operations as a calculator—addition,
subtraction, multiplication, and division. As you have already seen, addition and
subtraction use the familiar + and - operators, and the * operator denotes multiplication. Division is indicated with a /, not a fraction bar.
For example,

a+b/2

becomes

(a + b) / 2

Parentheses are used just as in algebra: to indicate in which order the subexpressions
should be computed. For example, in the expression (a + b) / 2, the sum a + b is
computed ﬁrst, and then the sum is divided by 2. In contrast, in the expression

a + b / 2

only b is divided by 2, and then the sum of a and b / 2 is formed. Just as in regular
algebraic notation, multiplication and division bind more strongly than addition
and subtraction. For example, in the expression a + b / 2, the / is carried out ﬁrst,
even though the + operation occurs farther to the left.

Incrementing a value by 1 is so common when writing programs that there is a special shorthand for it, namely

items++;

This statement adds 1 to items. It is easier to type and read than the equivalent
assignment statement

items = items + 1;

As you might have guessed, there is also a decrement operator --. The statement
items--;

subtracts 1 from items.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1552185391/Magis/Chapter%202/9.png</image>
			</page>
			<page title = "Arithmetic Operators">
				<text>
Division works as you would expect, as long as at least one of the numbers involved
is a ﬂoating-point number. That is,

7.0 / 4.0
7 / 4.0
7.0 / 4

all yield 1.75. However, if both numbers are integers, then the result of the division
is always an integer, with the remainder discarded. That is,

7 / 4

evaluates to 1, because 7 divided by 4 is 1 with a remainder of 3 (which is discarded).
Discarding the remainder is often useful, but it can also be a source of subtle programming errors—see Common Error 4.1 on page 142.
If you are interested only in the remainder of an integer division, use the % operator:

7 % 4

is 3, the remainder of the integer division of 7 by 4. The % symbol has no analog in
algebra. It was chosen because it looks similar to /, and the remainder operation is
related to division.
Here is a typical use for the integer / and % operations. Suppose you want to
know how much change a cash register should give, using separate values for dollars
and cents. You can compute the value as an integer, denominated in cents, and then
compute the whole dollar amount and the remaining change:

final int PENNIES_PER_NICKEL = 5;
final int PENNIES_PER_DIME = 10;
final int PENNIES_PER_QUARTER = 25;
final int PENNIES_PER_DOLLAR = 100;

// Compute total value in pennies
int total = dollars * PENNIES_PER_DOLLAR + quarters * PENNIES_PER_QUARTER
  + nickels * PENNIES_PER_NICKEL + dimes * PENNIES_PER_DIME + pennies;

// Use integer division to convert to dollars, cents
int dollars = total / PENNIES_PER_DOLLAR;
int cents = total % PENNIES_PER_DOLLAR;

For example, if total is 243, then dollars is set to 2 and cents to 43.

To compute x^n, you write Math.pow(x, n). However, to compute x^2 it is signiﬁcantly
more efﬁcient simply to compute x * x.
To take the square root of a number, you use the Math.sqrt method. For example,
x^(1/2) is written as Math.sqrt(x).
In algebra, you use fractions, superscripts for exponents, and radical signs for
roots to arrange expressions in a compact two-dimensional form. In Java, you have
to write all expressions in a linear arrangement.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%202/11.png</image>
			</page>
			<page title = "Arithmetic Operators">
				<text>
For example, the subexpression
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1552185392/Magis/Chapter%202/13.png</image>
				<text>
of the quadratic formula becomes

(-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a)

Figure 2 shows how to analyze such an expression. 

Table 2 shows additional methods of the Math class. Inputs and outputs are
ﬂoating-point numbers.
				</text>
			</page>
			<page title = "Casting">
				<text>
Occasionally, you have a value of type double that you need to convert to the type
int. Use the cast operator (int) for this purpose. You write the cast operator before
the expression that you want to convert:

double balance = total + tax;
int dollars = (int) balance;
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%202/15.png</image>
				<text>
The cast (int) converts the ﬂoating-point value balance to an integer by discarding
the fractional part. For example, if balance is 13.75, then dollars is set to 13.
The cast tells the compiler that you agree to information loss, in this case, to the
loss of the fractional part. You can also cast to other types, such as (float) or (byte).
If you want to round a ﬂoating-point number to the nearest whole number, use
the Math.round method. This method returns a long integer, because large ﬂoatingpoint numbers cannot be stored in an int.

long rounded = Math.round(balance);
				</text>
			</page>
			<page title = "Table 2">
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%202/17.png</image>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

3. What is the value of n after the following sequence of statements?
  n--;
  n++;
  n--;

4. What is the value of 1729 / 100? Of 1729 % 100?
5. Why doesn’t the following statement compute the average of s1, s2, and s3?
double average = s1 + s2 + s3 / 3; // Error
6. What is the value of Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) in mathematical
notation?
7. When does the cast (long) x yield a different result from the call Math.round(x)?
8. When does the cast (long) x yield a different result from the call Math.round(x)?
How do you round the double value x to the nearest int value, assuming that you
know that it is less than 2 · 10^9?
				</text>
			</page>
			<page title = "Strings">
				<text>
You can use the + operator to put strings together to form a longer string.

String name = "Dave";
String message = "Hello, " + name;

This process is called concatenation.
The + operator concatenates two strings, provided one of the expressions, either
to the left or the right of a + operator, is a string. The other one is automatically
forced to become a string as well, and both strings are concatenated.
For example, consider this code:

String a = "Agent";
int n = 7;
String bond = a + n;

Because a is a string, n is converted from the integer 7 to the string "7". Then the two
strings "Agent" and "7" are concatenated to form the string "Agent7".
This concatenation is very useful to reduce the number of System.out.print
instructions. For example, you can combine

System.out.print("The total is ");
System.out.println(total);

to the single call

System.out.println("The total is " + total);

The concatenation "The total is " + total computes a single string that consists of
the string "The total is ", followed by the string equivalent of the number total.

Sometimes you have a string that contains a number, usually from user input. For
example, suppose that the string variable input has the value "19". To get the integer
value 19, you use the static parseInt method of the Integer class.

int count = Integer.parseInt(input);
// count is the integer 19

To convert a string containing ﬂoating-point digits to its ﬂoating-point value, use
the static parseDouble method of the Double class. For example, suppose input is the
string "3.95".

double price = Double.parseDouble(input);
// price is the ﬂoating-point number 3.95

However, if the string contains spaces or other characters that cannot occur inside
numbers, an error occurs. For now, we will always assume that user input does not
contain invalid characters.

The substring method computes substrings of a string. The call

s.substring(start, pastEnd)

returns a string that is made up of the characters in the string s, starting at position
start, and containing all characters up to, but not including, the position pastEnd.
Here is an example:
String greeting = "Hello, World!";
String sub = greeting.substring(0, 5); // sub is "Hello"

The substring operation makes a string that consists of ﬁve characters taken from
the string greeting. A curious aspect of the substring operation is the numbering of
the starting and ending positions. The ﬁrst string position is labeled 0, the second
one 1, and so on. For example, Figure 3 shows the position numbers in the greeting
string.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%202/21.png</image>
				<text>
The position number of the last character (12 for the string "Hello, World!") is
always 1 less than the length of the string.
Let us ﬁgure out how to extract the substring "World". Count characters starting
at 0, not 1. You ﬁnd that W, the eighth character, has position number 7. The ﬁrst
character that you don’t want, !, is the character at position 12 (see Figure 4).
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1552185392/Magis/Chapter%202/23.png</image>
				<text>
Therefore, the appropriate substring command is

String sub2 = greeting.substring(7, 12);

It is curious that you must specify the position of the ﬁrst character that you do
want and then the ﬁrst character that you don’t want. There is one advantage to this
setup. You can easily compute the length of the substring: It is pastEnd - start. For
example, the string "World" has length 12 – 7 = 5.
If you omit the second parameter of the substring method, then all characters
from the starting position to the end of the string are copied. For example,

String tail = greeting.substring(7); // Copies all characters from position 7 on

sets tail to the string "World!".
If you supply an illegal string position (a negative number, or a value that is
larger than the length of the string), then your program terminates with an error
message.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

9. Assuming the String variable s holds the value "Agent", what is the effect of the
assignment s = s + s.length()?
10. Assuming the String variable river holds the value "Mississippi", what is the
value of river.substring(1, 2)? Of river.substring(2, river.length() - 3)?
				</text>
			</page>
			<page title = "Operators">
				<text>
Suppose you want to find whether amount is between 0 and 1000. Then two conditions have to be true: amount must be greater than 0, and it must be less than 1000. In
Java you use the &amp;&amp; operator to represent the and when combining test conditions.
That is, you can write the test as follows:

if (0 &lt; amount &amp;&amp; amount &lt; 1000) . . .

The &amp;&amp; (and) operator combines several tests into a new test that passes only when
all conditions are true. An operator that combines Boolean values is called a Boolean operator.
The &amp;&amp; operator has a lower precedence than the relational operators. For that
reason, you can write relational expressions on either side of the &amp;&amp; operator without using parentheses. For example, in the expression
0 &lt; amount &amp;&amp; amount &lt; 1000

the expressions 0 &lt; amount and amount &lt; 1000 are evaluated first. Then the &amp;&amp; operator
combines the results. Appendix B shows a table of the Java operators and their
precedence.
The || (or) logical operator also combines two or more conditions. The resulting
test succeeds if at least one of the conditions is true. For example, here is a test to
check whether the string input is an "S" or "M":
if (input.equals("S") || input.equals("M")) . . .

Figure 6 shows flowcharts for these examples.
Sometimes you need to invert a condition with the ! (not) logical operator. For
example, we may want to carry out a certain action only if two strings are not equal:
if (!input.equals("S")) . . .
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%202/27.png</image>
				<text>
The ! operator takes a single condition and evaluates to true if that condition is false
and to false if the condition is true.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1552185392/Magis/Chapter%202/29.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1552185392/Magis/Chapter%202/30.png</image>
				<text>
You can use a Boolean variable if you know that there are only two possible values.
Have another look at the tax program in Section 5.3.2. The marital status is either
single or married. Instead of using an integer, you can use a variable of type boolean:

private boolean married;

The advantage is that you can’t accidentally store a third value in the variable.
Then you can use the Boolean variable in a test:
if (married)
. . .
else
. . .

Sometimes Boolean variables are called flags because they can have only two states:
“up” and “down”.
It pays to think carefully about the naming of Boolean variables. In our example,
it would not be a good idea to give the name maritalStatus to the Boolean variable.
What does it mean that the marital status is true? With a name like married there is
no ambiguity; if married is true, the taxpayer is married.
By the way, it is considered gauche to write a test such as

if (married == true) . . . // Don’t

Just use the simpler test

if (married) . . .

SELF CHECK

11. When does the statement
System.out.println(x &gt; 0 || x &lt; 0);

12. print false?
Rewrite the following expression, avoiding the comparison with false:
if (Character.isDigit(ch) == false) . . .
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Homepage/3-object.png</image>
		<title>Object and Object Comparison</title>
		<description>Because Java is an Object-Oriented Language, it is important understand how to use classes, methods, and their components. In addition to these components, this chapter will go over the proper way of comparing two different objects</description>
		<pages>
			<page title = "What is an Object?">
				<text>
An object is a value that you can manipulate by calling one or more of its
methods. A method consists of a sequence of instructions that can access the internal data of an object. When you call the method, you do not know exactly what
those instructions are, or even how the object is organized internally. However, the
behavior of the method is well-defined, and that is what matters to us when we use
it.
For example, System.out refers to an object. You manipulate it by calling the println method. When the println method is called,
some activities occur inside the object, and the ultimate effect is that text appears in
the console window. You don’t know how that happens, and that’s OK. What matters is that the method carries out the work that you requested.
Figure 4 shows a representation of the System.out object. The internal data is symbolized by a sequence of zeroes and ones. Think of each method (symbolized by
the gears) as a piece of machinery that carries out its assigned task.

you encountered two objects:

• System.out
• "Hello, World!"

The type of an object is a class. The System.out object belongs to the class PrintStream. The "Hello, World!" object belongs to the class String. A class specifies the
methods that you can apply to its objects.
You can use the println method with any object that belongs to the PrintStream
class. System.out is one such object. It is possible to obtain other objects of the PrintStream class. For example, you can construct a PrintStream object to send output to a
file. However, we won’t discuss files until later.
Just as the PrintStream class provides methods such as println and print for its
objects, the String class provides methods that you can apply to String objects. One
of them is the length method. The length method counts the number of characters in a string.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/2.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/3.png</image>
				<text>
You can apply that method to any object of type String.

For example, the sequence of statements

String greeting = "Hello, World!";
int n = greeting.length();

sets n to the number of characters in the String object "Hello, World!". After the
instructions in the length method are executed, n is set to 13. (The quotation marks
are not part of the string, and the length method does not count them.)
The length method—unlike the println method—requires no input inside the parentheses. However, the length method yields an output, namely the character count.
In the next section, you will see in greater detail how to supply method inputs
and obtain method outputs.
Let us look at another method of the String class. When you apply the toUpperCase
method to a String object, the method creates another String object that contains the
characters of the original string, with lowercase letters converted to uppercase. For
example, the sequence of statements

String river = "Mississippi";
String bigRiver = river.toUpperCase();

sets bigRiver to the String object "MISSISSIPPI".
When you apply a method to an object, you must make sure that the method is
declared in the appropriate class. For example, it is an error to call
System.out.length(); // This method call is an error

The PrintStream class (to which System.out belongs) has no length method.
Let us summarize. In Java, every object belongs to a class. The class declares the
methods for the objects. For example, the String class declares the length and toUpperCase methods (as well as other methods—you will learn about most of them in
Chapter 4). The methods form the public interface of the class, telling you what you
can do with the objects of the class. A class also declares a private implementation,
describing the data inside its objects and the instructions for its methods. Those
details are hidden from the programmers who use objects and call methods.
Figure 5 shows two objects of the String class. Each object stores its own data
(drawn as boxes that contain characters). Both objects support the same set of
methods—the interface that is specified by the String class.

Occasionally, a class declares two methods with the same name and different
parameter types. For example, the PrintStream class declares a second method, also
called println, as

public void println(int output)

That method is used to print an integer value. We say that the println name is overloaded because it refers to more than one method.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. How can you compute the length of the string "Mississippi"?
2. How can you print out the uppercase version of "Hello, World!"?
3. Is it legal to call river.println()? Why or why not?
				</text>
			</page>
			<page title = "Constructing Objects">
				<text>
Most Java programs need to work on a variety of objects. In this section, you will
see how to construct new objects. This allows you to go beyond String objects and
the System.out object.

To learn about object construction, let us turn to another class: the Rectangle class
in the Java class library. Objects of type Rectangle describe rectangular shapes—see
Figure 10. These objects are useful for a variety of purposes. You can assemble rectangles into bar charts, and you can program simple games by moving rectangles
inside a window.

Note that a Rectangle object isn’t a rectangular shape—it’s an object that contains a
set of numbers. The numbers describe the rectangle (see Figure 11). Each rectangle is
described by the x- and y-coordinates of its top-left corner, its width, and its height.
It is very important that you understand this distinction. In the computer, a
Rectangle object is a block of memory that holds four numbers, for example x = 5,
y = 10, width = 20, height = 30. In the imagination of the programmer who uses a
Rectangle object, the object describes a geometric figure.
To make a new rectangle, you need to specify the x, y, width, and height values.
Then invoke the new operator, specifying the name of the class and the parameters
that are required for constructing a new object. For example, you can make a new
rectangle with its top-left corner at (5, 10), width 20, and height 30 as follows:
new Rectangle(5, 10, 20, 30)

Here is what happens in detail:
1. The new operator makes a Rectangle object.
2. It uses the parameters (in this case, 5, 10, 20, and 30) to initialize the data of the object.
3. It returns the object.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/6.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/7.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/8.png</image>
				<text>
The process of creating a new object is called construction. The four values 5, 10,
20, and 30 are called the construction parameters.
The new expression yields an object, and you need to store the object if you want
to use it later. Usually you assign the output of the new operator to a variable. For
example,

Rectangle box = new Rectangle(5, 10, 20, 30);

Some classes let you construct objects in multiple ways. For example, you can also
obtain a Rectangle object by supplying no construction parameters at all (but you
must still supply the parentheses):

new Rectangle()

This expression constructs a (rather useless) rectangle with its top-left corner at the
origin (0, 0), width 0, and height 0.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

4. How do you construct a square with center (100, 100) and side length 20?
5. The getWidth method returns the width of a Rectangle object. What does the following statement print?
System.out.println(new Rectangle().getWidth());
				</text>
			</page>
			<page title = "Methods">
				<text>
In this section we introduce a useful terminology for the methods of a class. A
method that accesses an object and returns some information about it, without
changing the object, is called an accessor method. In contrast, a method whose purpose is to modify the internal data of an object is called a mutator method.
For example, the length method of the String class is an accessor method. It
returns information about a string, namely its length. But it doesn’t modify the
string at all when counting the characters.
The Rectangle class has a number of accessor methods. The getX, getY, getWidth, and
getHeight methods return the x- and y-coordinates of the top-left corner, the width,
and the height values. For example,

double width = box.getWidth();

Now let us consider a mutator method. Programs that manipulate rectangles frequently need to move them around, for example, to display animations. The
Rectangle class has a method for that purpose, called translate. (Mathematicians use
the term “translation” for a rigid motion of the plane.) 

box.translate(15, 25);

This method moves a rectangle by a certain distance in the x- and y-directions. The method call,
moves the rectangle by 15 units in the x-direction and 25 units in the y-direction
(see Figure 12). Moving a rectangle doesn’t change its width or height, but it
changes the top-left corner. Afterward, the rectangle that had its top-left corner at
(5, 10) now has it at (20, 35).
This method is a mutator because it modifies the implicit parameter object.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/11.png</image>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

6. Is the toUpperCase method of the String class an accessor or a mutator?
7. Which call to translate is needed to move the rectangle declared by Rectangle
box = new Rectangle(5, 10, 20, 30) so that its top-left corner is the origin (0, 0)?
				</text>
			</page>
			<page title = "Object Memory">
				<text>
In Java, a variable whose type is a class does not actually hold an object. It merely
holds the memory location of an object. The object itself is stored elsewhere—see Figure 17.
There is a reason for this behavior. Objects can be very large. It is more efficient
to store only the memory location instead of the entire object.
We use the technical term object reference to denote the memory location of an
object. When a variable contains the memory location of an object, we say that it
refers to an object. For example, after the statement

Rectangle box = new Rectangle(5, 10, 20, 30);

the variable box refers to the Rectangle object that the new operator constructed. Technically speaking, the new operator returned a reference to the new object, and that
reference is stored in the box variable.

It is very important that you remember that the box variable does not contain the
object. It refers to the object. Two object variables can refer to the same object:

Rectangle box2 = box;
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/14.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/15.png</image>
				<text>
Now you can access the same Rectangle object both as box and as box2, as shown in Figure 18.
However, number variables actually store numbers. When you declare

int luckyNumber = 13;

then the luckyNumber variable holds the number 13, not a reference to the number
(see Figure 19). The reason is again efficiency. Because numbers require little storage, it is more efficient to store them directly in a variable.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/17.png</image>
				<text>
You can see the difference between number variables and object variables when you
make a copy of a variable. When you copy a number, the original and the copy of
the number are independent values. But when you copy an object reference, both
the original and the copy are references to the same object.
Consider the following code, which copies a number and then changes the copy
(see Figure 20):

int luckyNumber = 13; 
int luckyNumber2 = luckyNumber;
luckyNumber2 = 12; 

Now the variable luckyNumber contains the value 13, and luckyNumber2 contains 12.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/19.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/20.png</image>
				<text>
Now consider the seemingly analogous code with Rectangle objects (see Figure 21).

Rectangle box = new Rectangle(5, 10, 20, 30);
Rectangle box2 = box;
box2.translate(15, 25);

Since box and box2 refer to the same rectangle after step 2 , both variables refer to
the moved rectangle after the call to the translate method.
You need not worry too much about the difference between objects and object
references. Much of the time, you will have the correct intuition when you think of
“the object box” rather than the technically more accurate “the object reference
stored in box”. The difference between objects and object references only becomes
apparent when you have multiple variables that refer to the same object.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

8. What is the effect of the assignment: String greeting2 = greeting?
9. After calling greeting2.toUpperCase(), what are the contents of greeting and
greeting2?
				</text>
			</page>
			<page title = "Relational Operators">
				<text>
A relational operator tests the relationship between two values. An example is the
&lt;= operator that we used in the test
if (amount &lt;= balance)

Java has six relational operators:
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/23.png</image>
				<text>
As you can see, only two relational operators (&gt; and &lt;) look as you would expect
from the mathematical notation. Computer keyboards do not have keys for ≥, ≤, or
≠, but the &gt;=, &lt;=, and != operators are easy to remember because they look similar.
The == operator is initially confusing to most newcomers to Java. In Java, the =
symbol already has a meaning, namely assignment. The == operator denotes equality testing:

a = 5; // Assign 5 to a
if (a == 5) . . . // Test whether a equals 5

You will have to remember to use == for equality testing, and to use = for
assignment.
The relational operators have a lower precedence than the arithmetic operators.
That means, you can write arithmetic expressions on either side of the relational
operator without using parentheses. For example, in the expression

amount + fee &lt;= balance

both sides (amount + fee and balance) of the &lt; operator are evaluated, and the results
are compared. Appendix B shows a table of the Java operators and their precedence.

You have to be careful when comparing floating-point numbers, in order to cope
with roundoff errors. For example, the following code multiplies the square root of
2 by itself and then subtracts 2.

double r = Math.sqrt(2);
double d = r * r - 2;
if (d == 0)
  System.out.println("sqrt(2) squared minus 2 is 0");
else
  System.out.println(
  "sqrt(2) squared minus 2 is not 0 but " + d);

Even though the laws of mathematics tell us that
fragment prints

( 2 )2 − 2 equals 0, this program

sqrt(2) squared minus 2 is not 0 but 4.440892098500626E-16

Unfortunately, such roundoff errors are unavoidable. It plainly does not make sense
in most circumstances to compare floating-point numbers exactly. Instead, test
whether they are close enough.
To test whether a number x is close to zero, you can test whether the absolute
value | x| (that is, the number with its sign removed) is less than a very small threshold number. That threshold value is often called ε (the Greek letter epsilon). It is
common to set ε to 10–14 when testing double numbers.
Similarly, you can test whether two numbers are approximately equal by checking whether their difference is close to 0.

|x−y| ≤ε

In Java, we program the test as follows:

final double EPSILON = 1E-14;
if (Math.abs(x - y) &lt;= EPSILON)
// x is approximately equal to y
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/25.png</image>
			</page>
			<page title = "String Equality">
				<text>
To test whether two strings are equal to each other, you must use the method called
equals:

if (string1.equals(string2)) . . .

Do not use the == operator to compare strings. The expression

if (string1 == string2) // Not useful

has an unrelated meaning. It tests whether the two string variables refer to the identical string object. You can have strings with identical contents stored in different
objects, so this test never makes sense in actual programming; see Common Error
5.2 on page 180.
In Java, letter case matters. For example, "Harry" and "HARRY" are not the same
string. To ignore the letter case, use the equalsIgnoreCase method:

if (string1.equalsIgnoreCase(string2)) . . .

If two strings are not identical to each other, you still may want to know the relationship between them. The compareTo method compares strings in dictionary order. If

string1.compareTo(string2) &lt; 0

then the string string1 comes before the string string2 in the dictionary. For example, this is the case if string1 is "Harry", and string2 is "Hello". If

string1.compareTo(string2) &gt; 0

then string1 comes after string2 in dictionary order. Finally, if

string1.compareTo(string2) == 0

then string1 and string2 are equal.

Actually, the “dictionary” ordering used by Java is slightly different from that of
a normal dictionary. Java is case sensitive and sorts characters by putting numbers
first, then uppercase characters, then lowercase characters. For example, 1 comes
before B, which comes before a. The space character comes before all other
characters.
Let us investigate the comparison process closely. When Java compares two
strings, corresponding letters are compared until one of the strings ends or the first
difference is encountered. If one of the strings ends, the longer string is considered
the later one. If a character mismatch is found, the characters are compared to determine which string comes later in the dictionary sequence. This process is called lexicographic comparison. For example, let’s compare "car" with "cargo". The first
three letters match, and we reach the end of the first string. Therefore "car" comes
before "cargo" in the lexicographic ordering. Now compare "cathode" with "cargo".
The first two letters match. In the third character position, t comes after r, so the
string "cathode" comes after "cargo" in lexicographic ordering. (See Figure 3.)
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/27.png</image>
			</page>
			<page title = "Relational Operator Tbl.">
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/28.png</image>
			</page>
			<page title = "Common Relational Errors">
				<text>
Common Error 5.2: Using == to Compare Strings

It is an extremely common error in Java to write == when equals is intended. This is particularly true for strings. If you write

if (nickname == "Rob")

then the test succeeds only if the variable nickname refers to the exact same string object as the
string constant "Rob". For efficiency, Java makes only one string object for every string constant. Therefore, the following test will pass:

String nickname = "Rob";
. . .
if (nickname == "Rob") //Test is true

However, if the string with the letters R o b 
has been assembled in some other way, then the test will fail:

String name = "Robert";
String nickname = name.substring(0, 3);
. . .
if (nickname == "Rob") // Test is false

This is a particularly distressing situation: The wrong code will sometimes do the right thing,
sometimes the wrong thing. Because string objects are always constructed by the compiler,
you never have an interest in whether two string objects are shared. You must remember
never to use == to compare strings. Always use equals or compareTo to compare strings.

5.2.4 Comparing Objects

If you compare two object references with the == operator, you test whether the references refer to the same object. Here is an example:

Rectangle box1 = new Rectangle(5, 10, 20, 30);
Rectangle box2 = box1;
Rectangle box3 = new Rectangle(5, 10, 20, 30);

The comparison

box1 == box2

is true. Both object variables refer to the same object. But the comparison

box1 == box3

is false. The two object variables refer to different objects (see Figure 4). It does not
matter that the objects have identical contents.
You can use the equals method to test whether two rectangles have the same contents, that is, whether they have the same upper-left corner and the same width and
height. For example, the test

box1.equals(box3)

is true.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Chapter%203/30.png</image>
				<text>
However, you must be careful when using the equals method. It works correctly
only if the implementors of the class have supplied it. The Rectangle class has an
equals method that is suitable for comparing rectangles.
For your own classes, you need to supply an appropriate equals method. You will
learn how to do that in Chapter 10. Until that point, you should not use the equals
method to compare objects of your own classes.

5.2.5 Testing for null

An object reference can have the special value null if it refers to no object at all. It is
common to use the null value to indicate that a value has never been set. For example,

String middleInitial = null; // Not set
if ( . . . )
middleInitial = middleName.substring(0, 1);

You use the == operator (and not equals) to test whether an object reference is a null
reference:
if (middleInitial == null)
System.out.println(firstName + " " + lastName);
else
System.out.println(firstName + " " + middleInitial + ". " + lastName);

Note that the null reference is not the same as the empty string "". The empty string
is a valid string of length 0, whereas a null indicates that a string variable refers to no
string at all.

SELF CHECK

10. What is the value of s.length() if s is
  a. the empty string ""?
  b. the string " " containing a space?
  c. null?

11. Which of the following comparisons are syntactically incorrect? Which of them
are syntactically correct, but logically questionable?
  String a = "1";
  String b = "one";
  double x = 1;
  double y = 3 * (1.0 / 3);

  a. a == "1"
  b. a == null
  c. a.equals("")
  d. a == b
  e. a == x
  f. x == y
  g. x - y == null
  h. x.equals(y)
				</text>
			</page>
		</pages>
	</chapter>
</lesson>