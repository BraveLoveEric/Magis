<?xml version = "1.0"?>
<!--
STRUCTURE:
<lesson>
	<chapter>
		<image></image>
		<title></title>
		<description>
	</chapter>
</lesson>
-->
<lesson>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Homepage/comments.png</image>
		<title>Comments</title>
		<description>Become familiar with the three types of Java comments</description>
		<pages>
			<page>
				<text>
This line inside the main method is a comment:
// Display a greeting in the console window

This comment is purely for the beneﬁt of the human reader, to explain in more detail
what the next statement does. Any text enclosed between // and the end of the line is
completely ignored by the compiler. Comments are used to explain the program to other
programmers or to yourself.

There are three kinds of comments:

/* comment */
// one-line-comment
/** documentationComment */

The one-line comment extends to the end of the line. The other comments can span
multiple lines and extend to the */ delimiter.

A documentation comment is delimited by /** and */. You can comment

• Classes
• Methods
• Instance variables

Each comment is placed immediately above the feature it documents. Each /** . . . */
documentation comment contains introductory text followed by tagged documentation.
				</text>
			</page>
			<page title = "Commenting the Public Interface">
				<text>
When you implement classes and methods, you should get into the habit of thoroughly
commenting their behaviors. In Java there is a very useful standard form for
documentation comments. If you use this form in your classes, a program called
javadoc can automatically generate a neat set of HTML pages that describe them.
A documentation comment is placed before the class or method declaration that
is being documented. It starts with a /**, a special comment delimiter used by the
javadoc utility. Then you describe the method’s purpose. Then, for each method
parameter, you supply a line that starts with @param, followed by the parameter name
and a short explanation. Finally, you supply a line that starts with @return, describing
the return value. You omit the @param tag for methods that have no parameters,
and you omit the @return tag for methods whose return type is void.
The javadoc utility copies the first sentence of each comment to a summary table
in the HTML documentation. Therefore, it is best to write that first sentence with
some care. It should start with an uppercase letter and end with a period. It does not
have to be a grammatically complete sentence, but it should be meaningful when it
is pulled out of the comment and displayed in a summary.

Here are two typical examples.
/**

Withdraws money from the bank account.
@param amount the amount to withdraw
*/
public void withdraw(double amount)
{

implementation—filled in later
}
/**

Gets the current balance of the bank account.
@return the current balance
*/
public double getBalance()
{

implementation—filled in later
}

The comments you have just seen explain individual methods. Supply a brief comment for each
class, explaining its purpose. The comment syntax for class comments
is very simple: Just place the documentation comment above the class.
/**

A bank account has a balance that can be changed by
deposits and withdrawals.
*/
public class BankAccount
{
. . .
}

Your first reaction may well be “Whoa! Am I supposed to write all this stuff?”
These comments do seem pretty repetitive. But you should take the time to write
them, even if it feels silly.
It is always a good idea to write the method comment first, before writing the
code in the method body. This is an excellent test to see that you firmly understand
what you need to program. If you can’t explain what a class or method does, you
aren’t ready to implement it.
What about very simple methods? You can easily spend more time pondering
whether a comment is too trivial to write than it takes to write it. In practical
programming, very simple methods are rare. It is harmless to have a trivial method
overcommented, whereas a complicated method without any comment can cause
real grief to future maintenance programmers. According to the standard Java documentation
style, every class, every method, every parameter, and every return
value should have a comment.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. Provide documentation comments for the Counter class of Section 3.1.

2. Suppose we enhance the BankAccount class so that each account has an account
number. Supply a documentation comment for the constructor
public BankAccount(int accountNumber, double initialBalance)

3. Why is the following documentation comment questionable?

/**
Each account has an account number.
@return the account number of this account
*/
public int getAccountNumber()
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Homepage/1-primitive-types.png</image>
		<title>Primitive Types</title>
		<description>Become familiar with basic programming terminology and learn about the concepts of types, variables, and assignment</description>
		<pages>
			<page>
				<text>
A computer program processes values: numbers, strings, and more complex data
items. In Java, every value has a TYPE. (A type speciﬁes a set of values and 
the operations that can be carried out with the values.) For example, the number 13 has the type int
(an abbreviation for “integer”), "Hello, World" has the type String, and the object
System.out has the type PrintStream. The type tells you what operations you can carry
out with the values. For example, you can compute the sum or product of any two
integers. You can call println on any object of type PrintStream.
Java has separate types for INTEGERS and FLOATING-POINT numbers. Integers are
whole numbers; floating-point numbers can have fractional parts. For example, 13
is an integer and 1.3 is a floating-point number.
The name “floating-point” describes the representation of the number in the computer as a sequence of the significant digits and an indication of the position of the
decimal point. For example, the numbers 13000.0, 1.3, 0.00013 all have the same decimal digits: 13. When a floating-point number is multiplied or divided by 10, only
the position of the decimal point changes; it “floats”. This representation is related to
the “scientific” notation 1.3 × 10^(–4). (Actually, the computer represents numbers in
base 2, not base 10, but the principle is the same.)
If you need to process numbers with a fractional part, you should use the type
called DOUBLE (The double type denotes ﬂoatingpoint numbers that can have fractional parts.), 
which stands for “double precision floating-point number”. Think of
a number in double format as any number that can appear in the display panel of a
calculator, such as 1.3 or –0.333333333.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Primitive%20Types/2.png</image>
			</page>
			<page>
				<text>
When a value such as 13 or 1.3 occurs in a Java program, it is called a number literal.
Do not use commas when you write number literals in Java. For example,
13,000 must be written as 13000. To write numbers in exponential notation in Java,
use the notation En instead of “ × 10n ”. For example, 1.3 × 10–4 is written as 1.3E-4.
Table 1 shows how to write integer and floating-point literals in Java.
You may wonder why Java has separate integer and floating-point number types.
Pocket calculators don’t need a separate integer type; they use floating-point numbers for
all calculations. However, integers have several advantages over floating
point numbers. They take less storage space, are processed faster, and don’t cause
rounding errors. You will want to use the int type for quantities that can never have
fractional parts, such as the length of a string. Use the double type for quantities that
can have fractional parts, such as a grade point average.
There are several other number types in Java that are not as commonly used. We
will discuss these types in Chapter 4. For most programs in this book, however, the
int and double types are all you need for processing numbers.
In Java, the number types (int, double, and the less commonly used types) are
primitive types. Numbers are not objects. The number types have no methods.
However, you can combine numbers with operators such as + and -, as in 10 + n
or n - 1. To multiply two numbers, use the * operator. For example, 10 × n is written as 10 * n.
A combination of variables, literals, operators, and/or methods (which you will
see in Section 2.4) is called an expression. A typical example of an expression is
x + y * 2.

Numbers can be combined by arithmetic operators such as +, -, and *.

As in mathematics, the * operator binds more strongly than the + operator. That is,
x + y * 2 means the sum of x and y * 2. If you want to multiply the sum of x and y
by 2, use parentheses:
(x + y) * 2
				</text>
			</page>
			<page title = "Self Check">
				<text>
Self Check

1. What are the types of the values 0 and "0"?
2. Which number type would you use for storing the area of a circle?
3. Why is the expression 13.println() an error?
4. Write an expression to compute the average of the values x and y.
				</text>
			</page>
			<page>
				<text>
In Java, every value is either a reference to an object, or it belongs to one of the eight
primitive types shown in Table 1.
Six of the primitive types are number types; four of them for integers and two for
ﬂoating-point numbers.

The largest number that can be represented in an int is denoted by Integer.MAX_VALUE.
Its value is about 2.14 billion. Similarly, Integer.MIN_VALUE is the smallest integer,
about –2.14 billion. Generally, you will use the int type for integer quantities. However,
occasionally, calculations involving integers can overflow. This happens if the result of
a computation exceeds the range for the number type. For example:

int n = 1000000;
System.out.println(n * n); // Prints –727379968, which is clearly wrong

The product n * n is 1012, which is larger than the largest integer (about 2 · 109). The
result is truncated to ﬁt into an int, yielding a value that is completely wrong.

Unfortunately, there is no warning when an integer overﬂow occurs.
If you run into this problem, the simplest remedy is to use the long type.

Overﬂow is not usually a problem for double-precision ﬂoating-point numbers.
The double type has a range of about ±10308 and about 15 signiﬁcant digits. However,
you want to avoid the float type—it has less than 7 signiﬁcant digits. (Some
programmers use float to save on memory if they need to store a huge set of numbers
that do not require much precision.)
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Primitive%20Types/2.png</image>
			</page>
			<page>
				<text>
Rounding errors are a more serious issue with ﬂoating-point values. Rounding
errors can occur when you convert between binary and decimal numbers, or
between integers and ﬂoating-point numbers. When a value cannot be converted
exactly, it is rounded to the nearest match. Consider this example:

double f = 4.35;
System.out.println(100 * f); // Prints 434.99999999999994

This problem is caused because computers represent numbers in the binary number
system. In the binary number system, there is no exact representation of the fraction 1/10,
just as there is no exact representation of the fraction 1/3 = 0.33333 in the
decimal number system. (See Special Topic 4.2 on page 130 for more information.)
For this reason, the double type is not appropriate for ﬁnancial calculations. In
this book, we will continue to use double values for bank balances and other ﬁnancial
quantities so that we keep our programs as simple as possible. However,
professional programs need to use the BigDecimal type for this purpose—see Special
Topic 4.1 on page 130.
In Java, it is legal to assign an integer value to a ﬂoating-point variable:

int dollars = 100;
double balance = dollars; // OK

But the opposite assignment is an error:
You cannot assign a ﬂoating-point expression to an integer variable.

double balance = 13.75;
int dollars = balance; // Error
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. Which are the most commonly used number types in Java?

2. Suppose you want to write a program that works with population data from
various countries. Which Java data type should you use?

3. Which of the following initializations are incorrect, and why?
	a. int dollars = 100.0;
	b. double balance = 100;
				</text>
			</page>
			<page>
				<text>
In Java, strings are objects that belong to the class String. (You can tell that String is
a class name because it starts with an uppercase letter. The primitive types int and
double start with lowercase letters.)
You do not need to call a constructor to create a string object. You can obtain a
string literal simply by enclosing a sequence of characters in double quotation
marks. For example, the string literal "Harry" is an object of the String class.
The number of characters in a string is called the length of the string. As you
have seen, you can use the length method to obtain the length of a
string. For example, "Hello".length() is 5, and the length of "Hello, World!" is 13.
(The quotation marks are not part of the string and do not contribute to the length,
but you must count spaces and punctuation marks.)
A string of length zero, containing no characters, is called the empty string and is
written as "".
				</text>
			</page>
			<page>
				<text>
In Java, an expression such as amount &lt; 1000 has a value, just as the expression
amount + 1000 has a value. The value of a relational expression is either true or false.
For example, if amount is 500, then the value of amount &lt; 1000 is true. Try it out: The
program fragment

double amount = 0;
bool lessThanThousand = amount &lt; 1000;
System.out.println(lessThanThousand);

prints true. The values true and false are not numbers, nor are they objects of a
class. They belong to a separate type, called boolean. The Boolean type is named
after the mathematician George Boole (1815–1864), a pioneer in the study of logic.
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Homepage/2-operators.png</image>
		<title>Operators</title>
		<description>Learn how to use operators to manipulate variables. From changing the values of variables to casting variables to different types, you'll understand how to control and utilize your data</description>
		<pages>
			<page title = "Assignment Operator">
				<text>
You can change the value of a variable with the assignment operator (=).
For example, consider the variable declaration

int width = 10;

If you want to change the value of the variable, simply assign the new value:

width = 20;

The assignment replaces the original value of the variable (see Figure 1).
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Operators/2.png</image>
			</page>
			<page title = "Assignment Errors">
				<text>
It is an error to use a variable that has never had a value assigned to it. For example,
the following assignment statement has an error:
int height;
width = height;

// ERROR—uninitialized variable height

The compiler will complain about an “uninitialized variable” when you use a
variable that has never been assigned a value. (See Figure 2.)
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Operators/4.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Operators/5.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Operators/6.png</image>
			</page>
			<page title = "Good Assignment Practice">
				<text>
The remedy is to assign a value to the variable before you use it:
All variables must be initialized before you access them.

int height = 30;
width = height; // OK

Or, even better, initialize the variable when you declare it.
int height = 30;
int width = height; // OK

The right-hand side of the = symbol can be a mathematical expression. For example,

width = height + 10;

This means “compute the value of height + 10 and store that value in the variable
width”.
In the Java programming language, the = operator denotes an action, to replace the
value of a variable. This usage differs from the mathematical usage of the = symbol,
as a statement about equality. For example, in Java, the following statement is
entirely legal:
width = width + 10;

This means “compute the value of width + 10 (figure 3.1) and store that value in the variable
width (figure 3.2) ” 

In Java, it is not a problem that the variable width is used on both sides of the =
symbol. Of course, in mathematics, the equation width = width + 10 has no solution.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK
1. Is 12 = 12 a valid expression in the Java language?
2. How do you change the value of the greeting variable to "Hello, Nina!"?
				</text>
			</page>
			<page title = "Common Error: Confusing Variable Declarations and Assignment Statements">
				<text>
Suppose your program declares a variable as follows:
int width = 20;

If you want to change the value of the variable, you use an assignment statement:
width = 30;

It is a common error to accidentally use another variable declaration:
int width = 30; // ERROR—starts with int and is therefore a declaration

But there is already a variable named width. The compiler will complain that you are trying
to declare another variable with the same name.
				</text>
			</page>
			<page title = "Arithmetic Operators">
				<text>
Java supports the same four basic arithmetic operations as a calculator—addition,
subtraction, multiplication, and division. As you have already seen, addition and
subtraction use the familiar + and - operators, and the * operator denotes multiplication.
Division is indicated with a /, not a fraction bar. For example,

a+b/2

becomes

(a + b) / 2

Parentheses are used just as in algebra: to indicate in which order the subexpressions
should be computed. For example, in the expression (a + b) / 2, the sum a + b is
computed ﬁrst, and then the sum is divided by 2. In contrast, in the expression

a + b / 2

only b is divided by 2, and then the sum of a and b / 2 is formed. Just as in regular
algebraic notation, multiplication and division bind more strongly than addition
and subtraction. For example, in the expression a + b / 2, the / is carried out ﬁrst,
even though the + operation occurs farther to the left.

Incrementing a value by 1 is so common when writing programs that there is a special shorthand for it, namely

items++;

This statement adds 1 to items. It is easier to type and read than the equivalent
assignment statement

items = items + 1;

As you might have guessed, there is also a decrement operator --. The statement
items--;

subtracts 1 from items.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1552185391/Magis/Operators/9.png</image>
			</page>
			<page title = "Arithmetic Operators">
				<text>
Division works as you would expect, as long as at least one of the numbers involved
is a ﬂoating-point number. That is,

7.0 / 4.0
7 / 4.0
7.0 / 4

all yield 1.75. However, if both numbers are integers, then the result of the division
is always an integer, with the remainder discarded. That is,

7 / 4

evaluates to 1, because 7 divided by 4 is 1 with a remainder of 3 (which is discarded).
Discarding the remainder is often useful, but it can also be a source of subtle programming errors.
If you are interested only in the remainder of an integer division, use the % operator:

7 % 4

is 3, the remainder of the integer division of 7 by 4. The % symbol has no analog in
algebra. It was chosen because it looks similar to /, and the remainder operation is
related to division.
Here is a typical use for the integer / and % operations. Suppose you want to
know how much change a cash register should give, using separate values for dollars
and cents. You can compute the value as an integer, denominated in cents, and then
compute the whole dollar amount and the remaining change:

final int PENNIES_PER_NICKEL = 5;
final int PENNIES_PER_DIME = 10;
final int PENNIES_PER_QUARTER = 25;
final int PENNIES_PER_DOLLAR = 100;

// Compute total value in pennies
int total = dollars * PENNIES_PER_DOLLAR + quarters * PENNIES_PER_QUARTER
  + nickels * PENNIES_PER_NICKEL + dimes * PENNIES_PER_DIME + pennies;

// Use integer division to convert to dollars, cents
int dollars = total / PENNIES_PER_DOLLAR;
int cents = total % PENNIES_PER_DOLLAR;

For example, if total is 243, then dollars is set to 2 and cents to 43.

To compute x^n, you write Math.pow(x, n). However, to compute x^2 it is signiﬁcantly
more efﬁcient simply to compute x * x.
To take the square root of a number, you use the Math.sqrt method. For example,
x^(1/2) is written as Math.sqrt(x).
In algebra, you use fractions, superscripts for exponents, and radical signs for
roots to arrange expressions in a compact two-dimensional form. In Java, you have
to write all expressions in a linear arrangement.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Operators/11.png</image>
			</page>
			<page title = "Arithmetic Operators">
				<text>
For example, the subexpression
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1552185392/Magis/Operators/13.png</image>
				<text>
of the quadratic formula becomes

(-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a)

Figure 2 shows how to analyze such an expression. 

Table 2 shows additional methods of the Math class. Inputs and outputs are
ﬂoating-point numbers.
				</text>
			</page>
			<page title = "Casting">
				<text>
Occasionally, you have a value of type double that you need to convert to the type
int. Use the cast operator (int) for this purpose. You write the cast operator before
the expression that you want to convert:

double balance = total + tax;
int dollars = (int) balance;
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Operators/15.png</image>
				<text>
The cast (int) converts the ﬂoating-point value balance to an integer by discarding
the fractional part. For example, if balance is 13.75, then dollars is set to 13.
The cast tells the compiler that you agree to information loss, in this case, to the
loss of the fractional part. You can also cast to other types, such as (float) or (byte).
If you want to round a ﬂoating-point number to the nearest whole number, use
the Math.round method. This method returns a long integer, because large ﬂoatingpoint
numbers cannot be stored in an int.

long rounded = Math.round(balance);
				</text>
			</page>
			<page title = "Table 2">
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Operators/17.png</image>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. What is the value of n after the following sequence of statements?
  n--;
  n++;
  n--;

2. What is the value of 1729 / 100? Of 1729 % 100?
3. Why doesn’t the following statement compute the average of s1, s2, and s3?
double average = s1 + s2 + s3 / 3; // Error
4. What is the value of Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) in mathematical
notation?
5. When does the cast (long) x yield a different result from the call Math.round(x)?
6. When does the cast (long) x yield a different result from the call Math.round(x)?
How do you round the double value x to the nearest int value, assuming that you
know that it is less than 2 · 10^9?
				</text>
			</page>
			<page title = "Strings">
				<text>
You can use the + operator to put strings together to form a longer string.

String name = "Dave";
String message = "Hello, " + name;

This process is called concatenation.
The + operator concatenates two strings, provided one of the expressions, either
to the left or the right of a + operator, is a string. The other one is automatically
forced to become a string as well, and both strings are concatenated.
For example, consider this code:

String a = "Agent";
int n = 7;
String bond = a + n;

Because a is a string, n is converted from the integer 7 to the string "7". Then the two
strings "Agent" and "7" are concatenated to form the string "Agent7".
This concatenation is very useful to reduce the number of System.out.print
instructions. For example, you can combine

System.out.print("The total is ");
System.out.println(total);

to the single call

System.out.println("The total is " + total);

The concatenation "The total is " + total computes a single string that consists of
the string "The total is ", followed by the string equivalent of the number total.

Sometimes you have a string that contains a number, usually from user input. For
example, suppose that the string variable input has the value "19". To get the integer
value 19, you use the static parseInt method of the Integer class.

int count = Integer.parseInt(input);
// count is the integer 19

To convert a string containing ﬂoating-point digits to its ﬂoating-point value, use
the static parseDouble method of the Double class. For example, suppose input is the
string "3.95".

double price = Double.parseDouble(input);
// price is the ﬂoating-point number 3.95

However, if the string contains spaces or other characters that cannot occur inside
numbers, an error occurs. For now, we will always assume that user input does not
contain invalid characters.

The substring method computes substrings of a string. The call

s.substring(start, pastEnd)

returns a string that is made up of the characters in the string s, starting at position
start, and containing all characters up to, but not including, the position pastEnd.
Here is an example:
String greeting = "Hello, World!";
String sub = greeting.substring(0, 5); // sub is "Hello"

The substring operation makes a string that consists of ﬁve characters taken from
the string greeting. A curious aspect of the substring operation is the numbering of
the starting and ending positions. The ﬁrst string position is labeled 0, the second
one 1, and so on. For example, Figure 3 shows the position numbers in the greeting
string.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Operators/21.png</image>
				<text>
The position number of the last character (12 for the string "Hello, World!") is
always 1 less than the length of the string.
Let us ﬁgure out how to extract the substring "World". Count characters starting
at 0, not 1. You ﬁnd that W, the eighth character, has position number 7. The ﬁrst
character that you don’t want, !, is the character at position 12 (see Figure 4).
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1552185392/Magis/Operators/23.png</image>
				<text>
Therefore, the appropriate substring command is

String sub2 = greeting.substring(7, 12);

It is curious that you must specify the position of the ﬁrst character that you do
want and then the ﬁrst character that you don’t want. There is one advantage to this
setup. You can easily compute the length of the substring: It is pastEnd - start. For
example, the string "World" has length 12 – 7 = 5.
If you omit the second parameter of the substring method, then all characters
from the starting position to the end of the string are copied. For example,

String tail = greeting.substring(7); // Copies all characters from position 7 on

sets tail to the string "World!".
If you supply an illegal string position (a negative number, or a value that is
larger than the length of the string), then your program terminates with an error
message.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. Assuming the String variable s holds the value "Agent", what is the effect of the
assignment s = s + s.length()?
2. Assuming the String variable river holds the value "Mississippi", what is the
value of river.substring(1, 2)? Of river.substring(2, river.length() - 3)?
				</text>
			</page>
			<page title = "Operators">
				<text>
Suppose you want to find whether amount is between 0 and 1000. Then two conditions
have to be true: amount must be greater than 0, and it must be less than 1000. In
Java you use the &amp;&amp; operator to represent the and when combining test conditions.
That is, you can write the test as follows:

if (0 &lt; amount &amp;&amp; amount &lt; 1000) . . .

The &amp;&amp; (and) operator combines several tests into a new test that passes only when
all conditions are true. An operator that combines Boolean values is called a Boolean operator.
The &amp;&amp; operator has a lower precedence than the relational operators. For that
reason, you can write relational expressions on either side of the &amp;&amp; operator
without using parentheses. For example, in the expression

0 &lt; amount &amp;&amp; amount &lt; 1000

the expressions 0 &lt; amount and amount &lt; 1000 are evaluated first. Then the &amp;&amp; operator
combines the results. Appendix B shows a table of the Java operators and their
precedence.
The || (or) logical operator also combines two or more conditions. The resulting
test succeeds if at least one of the conditions is true. For example, here is a test to
check whether the string input is an "S" or "M":
if (input.equals("S") || input.equals("M")) . . .

Figure 6 shows flowcharts for these examples.
Sometimes you need to invert a condition with the ! (not) logical operator. For
example, we may want to carry out a certain action only if two strings are not equal:
if (!input.equals("S")) . . .
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Operators/27.png</image>
				<text>
The ! operator takes a single condition and evaluates to true if that condition is false
and to false if the condition is true.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1552185392/Magis/Operators/29.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1552185392/Magis/Operators/30.png</image>
				<text>
You can use a Boolean variable if you know that there are only two possible values.
Have another look at the tax program in Section 5.3.2. The marital status is either
single or married. Instead of using an integer, you can use a variable of type boolean:

private boolean married;

The advantage is that you can’t accidentally store a third value in the variable.
Then you can use the Boolean variable in a test:
if (married)
. . .
else
. . .

Sometimes Boolean variables are called flags because they can have only two states:
“up” and “down”.
It pays to think carefully about the naming of Boolean variables. In our example,
it would not be a good idea to give the name maritalStatus to the Boolean variable.
What does it mean that the marital status is true? With a name like married there is
no ambiguity; if married is true, the taxpayer is married.
By the way, it is considered gauche to write a test such as

if (married == true) . . . // Don’t

Just use the simpler test

if (married) . . .
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. When does the statement print false?
System.out.println(x &gt; 0 || x &lt; 0);

2. Rewrite the following expression, avoiding the comparison with false:
if (Character.isDigit(ch) == false) . . .
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Homepage/3-object.png</image>
		<title>Object and Object Comparison</title>
		<description>Because Java is an Object-Oriented Language, it is important understand how to use classes, methods, and their components. In addition to these components, this chapter will go over the proper way of comparing two different objects</description>
		<pages>
			<page title = "What is an Object?">
				<text>
An object is a value that you can manipulate by calling one or more of its
methods. A method consists of a sequence of instructions that can access the
internal data of an object. When you call the method, you do not know exactly what
those instructions are, or even how the object is organized internally. However, the
behavior of the method is well-defined, and that is what matters to us when we use
it.
For example, System.out refers to an object. You manipulate it by calling the
println method. When the println method is called, some activities occur inside
the object, and the ultimate effect is that text appears in the console window.
You don’t know how that happens, and that’s OK. What matters is that the method
carries out the work that you requested. Figure 4 shows a representation of the
System.out object. The internal data is symbolized by a sequence of zeroes and ones.
Think of each method (symbolized by the gears) as a piece of machinery that carries
out its assigned task. You encountered two objects:

• System.out
• "Hello, World!"

The type of an object is a class. The System.out object belongs to the class
PrintStream. The "Hello, World!" object belongs to the class String. A class specifies the
methods that you can apply to its objects.

You can use the println method with any object that belongs to the PrintStream
class. System.out is one such object. It is possible to obtain other objects of the
PrintStream class. For example, you can construct a PrintStream object to send output to a
file. However, we won’t discuss files until later.
Just as the PrintStream class provides methods such as println and print for its
objects, the String class provides methods that you can apply to String objects. One
of them is the length method. The length method counts the number of characters in a string.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/2.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/3.png</image>
				<text>
You can apply that method to any object of type String.

For example, the sequence of statements

String greeting = "Hello, World!";
int n = greeting.length();

sets n to the number of characters in the String object "Hello, World!". After the
instructions in the length method are executed, n is set to 13. (The quotation marks
are not part of the string, and the length method does not count them.)
The length method—unlike the println method—requires no input inside the parentheses.
However, the length method yields an output, namely the character count.
In the next section, you will see in greater detail how to supply method inputs
and obtain method outputs.
Let us look at another method of the String class. When you apply the toUpperCase
method to a String object, the method creates another String object that contains the
characters of the original string, with lowercase letters converted to uppercase. For
example, the sequence of statements

String river = "Mississippi";
String bigRiver = river.toUpperCase();

sets bigRiver to the String object "MISSISSIPPI".
When you apply a method to an object, you must make sure that the method is
declared in the appropriate class. For example, it is an error to call
System.out.length(); // This method call is an error

The PrintStream class (to which System.out belongs) has no length method.
Let us summarize. In Java, every object belongs to a class. The class declares the
methods for the objects. For example, the String class declares the length and
toUpperCase methods (as well as other methods—you will learn about most of them in
Chapter 4). The methods form the public interface of the class, telling you what you
can do with the objects of the class. A class also declares a private implementation,
describing the data inside its objects and the instructions for its methods. Those
details are hidden from the programmers who use objects and call methods.
Figure 5 shows two objects of the String class. Each object stores its own data
(drawn as boxes that contain characters). Both objects support the same set of
methods—the interface that is specified by the String class.

Occasionally, a class declares two methods with the same name and different
parameter types. For example, the PrintStream class declares a second method, also
called println, as

public void println(int output)

That method is used to print an integer value. We say that the println name is
overloaded because it refers to more than one method.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. How can you compute the length of the string "Mississippi"?
2. How can you print out the uppercase version of "Hello, World!"?
3. Is it legal to call river.println()? Why or why not?
				</text>
			</page>
			<page title = "Constructing Objects">
				<text>
Most Java programs need to work on a variety of objects. In this section, you will
see how to construct new objects. This allows you to go beyond String objects and
the System.out object.

To learn about object construction, let us turn to another class: the Rectangle class
in the Java class library. Objects of type Rectangle describe rectangular shapes—see
Figure 10. These objects are useful for a variety of purposes. You can assemble
rectangles into bar charts, and you can program simple games by moving rectangles
inside a window.

Note that a Rectangle object isn’t a rectangular shape—it’s an object that contains a
set of numbers. The numbers describe the rectangle (see Figure 11). Each rectangle is
described by the x- and y-coordinates of its top-left corner, its width, and its height.
It is very important that you understand this distinction. In the computer, a
Rectangle object is a block of memory that holds four numbers, for example x = 5,
y = 10, width = 20, height = 30. In the imagination of the programmer who uses a
Rectangle object, the object describes a geometric figure.
To make a new rectangle, you need to specify the x, y, width, and height values.
Then invoke the new operator, specifying the name of the class and the parameters
that are required for constructing a new object. For example, you can make a new
rectangle with its top-left corner at (5, 10), width 20, and height 30 as follows:
new Rectangle(5, 10, 20, 30)

Here is what happens in detail:
1. The new operator makes a Rectangle object.
2. It uses the parameters (in this case, 5, 10, 20, and 30) to initialize the data of the object.
3. It returns the object.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/6.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/7.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/8.png</image>
				<text>
The process of creating a new object is called construction. The four values 5, 10,
20, and 30 are called the construction parameters.
The new expression yields an object, and you need to store the object if you want
to use it later. Usually you assign the output of the new operator to a variable. For
example,

Rectangle box = new Rectangle(5, 10, 20, 30);

Some classes let you construct objects in multiple ways. For example, you can also
obtain a Rectangle object by supplying no construction parameters at all (but you
must still supply the parentheses):

new Rectangle()

This expression constructs a (rather useless) rectangle with its top-left corner at the
origin (0, 0), width 0, and height 0.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. How do you construct a square with center (100, 100) and side length 20?
2. The getWidth method returns the width of a Rectangle object. What does
the following statement print?
System.out.println(new Rectangle().getWidth());
				</text>
			</page>
			<page title = "Methods">
				<text>
In this section we introduce a useful terminology for the methods of a class. A
method that accesses an object and returns some information about it, without
changing the object, is called an accessor method. In contrast, a method whose
purpose is to modify the internal data of an object is called a mutator method.
For example, the length method of the String class is an accessor method. It
returns information about a string, namely its length. But it doesn’t modify the
string at all when counting the characters.
The Rectangle class has a number of accessor methods. The getX, getY, getWidth, and
getHeight methods return the x- and y-coordinates of the top-left corner, the width,
and the height values. For example,

double width = box.getWidth();

Now let us consider a mutator method. Programs that manipulate rectangles frequently
need to move them around, for example, to display animations. The Rectangle class
has a method for that purpose, called translate. (Mathematicians use the term “translation”
for a rigid motion of the plane.)

box.translate(15, 25);

This method moves a rectangle by a certain distance in the x- and y-directions. The method call,
moves the rectangle by 15 units in the x-direction and 25 units in the y-direction
(see Figure 12). Moving a rectangle doesn’t change its width or height, but it
changes the top-left corner. Afterward, the rectangle that had its top-left corner at
(5, 10) now has it at (20, 35).
This method is a mutator because it modifies the implicit parameter object.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/11.png</image>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. Is the toUpperCase method of the String class an accessor or a mutator?
2. Which call to translate is needed to move the rectangle declared by Rectangle
box = new Rectangle(5, 10, 20, 30) so that its top-left corner is the origin (0, 0)?
				</text>
			</page>
			<page title = "Object Memory">
				<text>
In Java, a variable whose type is a class does not actually hold an object. It merely
holds the memory location of an object. The object itself is stored elsewhere—see Figure 17.
There is a reason for this behavior. Objects can be very large. It is more efficient
to store only the memory location instead of the entire object.
We use the technical term object reference to denote the memory location of an
object. When a variable contains the memory location of an object, we say that it
refers to an object. For example, after the statement

Rectangle box = new Rectangle(5, 10, 20, 30);

the variable box refers to the Rectangle object that the new operator constructed.
Technically speaking, the new operator returned a reference to the new object, and that
reference is stored in the box variable.

It is very important that you remember that the box variable does not contain the
object. It refers to the object. Two object variables can refer to the same object:

Rectangle box2 = box;
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/14.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/15.png</image>
				<text>
Now you can access the same Rectangle object both as box and as box2, as shown in Figure 18.
However, number variables actually store numbers. When you declare

int luckyNumber = 13;

then the luckyNumber variable holds the number 13, not a reference to the number
(see Figure 19). The reason is again efficiency. Because numbers require little
storage, it is more efficient to store them directly in a variable.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/17.png</image>
				<text>
You can see the difference between number variables and object variables when you
make a copy of a variable. When you copy a number, the original and the copy of
the number are independent values. But when you copy an object reference, both
the original and the copy are references to the same object.
Consider the following code, which copies a number and then changes the copy
(see Figure 20):

int luckyNumber = 13; 
int luckyNumber2 = luckyNumber;
luckyNumber2 = 12; 

Now the variable luckyNumber contains the value 13, and luckyNumber2 contains 12.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/19.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/20.png</image>
				<text>
Now consider the seemingly analogous code with Rectangle objects (see Figure 21).

Rectangle box = new Rectangle(5, 10, 20, 30);
Rectangle box2 = box;
box2.translate(15, 25);

Since box and box2 refer to the same rectangle after step 2 , both variables refer to
the moved rectangle after the call to the translate method.
You need not worry too much about the difference between objects and object
references. Much of the time, you will have the correct intuition when you think of
“the object box” rather than the technically more accurate “the object reference
stored in box”. The difference between objects and object references only becomes
apparent when you have multiple variables that refer to the same object.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. What is the effect of the assignment: String greeting2 = greeting?
2. After calling greeting2.toUpperCase(), what are the contents of greeting and
greeting2?
				</text>
			</page>
			<page title = "Relational Operators">
				<text>
A relational operator tests the relationship between two values. An example is the
&lt;= operator that we used in the test
if (amount &lt;= balance)

Java has six relational operators:
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/23.png</image>
				<text>
As you can see, only two relational operators (&gt; and &lt;) look as you would expect
from the mathematical notation. Computer keyboards do not have keys for ≥, ≤, or
≠, but the &gt;=, &lt;=, and != operators are easy to remember because they look similar.
The == operator is initially confusing to most newcomers to Java. In Java, the =
symbol already has a meaning, namely assignment. The == operator denotes equality testing:

a = 5; // Assign 5 to a
if (a == 5) . . . // Test whether a equals 5

You will have to remember to use == for equality testing, and to use = for
assignment.
The relational operators have a lower precedence than the arithmetic operators.
That means, you can write arithmetic expressions on either side of the relational
operator without using parentheses. For example, in the expression

amount + fee &lt;= balance

both sides (amount + fee and balance) of the &lt; operator are evaluated, and the results
are compared. Appendix B shows a table of the Java operators and their precedence.

You have to be careful when comparing floating-point numbers, in order to cope
with roundoff errors. For example, the following code multiplies the square root of
2 by itself and then subtracts 2.

double r = Math.sqrt(2);
double d = r * r - 2;
if (d == 0)
  System.out.println("sqrt(2) squared minus 2 is 0");
else
  System.out.println(
  "sqrt(2) squared minus 2 is not 0 but " + d);

Even though the laws of mathematics tell us that
fragment prints

( 2 )2 − 2 equals 0, this program

sqrt(2) squared minus 2 is not 0 but 4.440892098500626E-16

Unfortunately, such roundoff errors are unavoidable. It plainly does not make sense
in most circumstances to compare floating-point numbers exactly. Instead, test
whether they are close enough.
To test whether a number x is close to zero, you can test whether the absolute
value | x| (that is, the number with its sign removed) is less than a very small
threshold number. That threshold value is often called ε (the Greek letter epsilon). It is
common to set ε to 10–14 when testing double numbers.
Similarly, you can test whether two numbers are approximately equal by checking
whether their difference is close to 0.

|x−y| ≤ε

In Java, we program the test as follows:

final double EPSILON = 1E-14;
if (Math.abs(x - y) &lt;= EPSILON)
// x is approximately equal to y
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/25.png</image>
			</page>
			<page title = "String Equality">
				<text>
To test whether two strings are equal to each other, you must use the method called
equals:

if (string1.equals(string2)) . . .

Do not use the == operator to compare strings. The expression

if (string1 == string2) // Not useful

has an unrelated meaning. It tests whether the two string variables refer to the
identical string object. You can have strings with identical contents stored in different
objects, so this test never makes sense in actual programming; see Common Error
5.2 on page 180.
In Java, letter case matters. For example, "Harry" and "HARRY" are not the same
string. To ignore the letter case, use the equalsIgnoreCase method:

if (string1.equalsIgnoreCase(string2)) . . .

If two strings are not identical to each other, you still may want to know the
relationship between them. The compareTo method compares strings in dictionary order. If

string1.compareTo(string2) &lt; 0

then the string string1 comes before the string string2 in the dictionary.
For example, this is the case if string1 is "Harry", and string2 is "Hello". If

string1.compareTo(string2) &gt; 0

then string1 comes after string2 in dictionary order. Finally, if

string1.compareTo(string2) == 0

then string1 and string2 are equal.

Actually, the “dictionary” ordering used by Java is slightly different from that of
a normal dictionary. Java is case sensitive and sorts characters by putting numbers
first, then uppercase characters, then lowercase characters. For example, 1 comes
before B, which comes before a. The space character comes before all other
characters.
Let us investigate the comparison process closely. When Java compares two
strings, corresponding letters are compared until one of the strings ends or the first
difference is encountered. If one of the strings ends, the longer string is considered
the later one. If a character mismatch is found, the characters are compared to determine
which string comes later in the dictionary sequence. This process is called lexicographic
comparison. For example, let’s compare "car" with "cargo". The first three letters match,
and we reach the end of the first string. Therefore "car" comes before "cargo" in the
lexicographic ordering. Now compare "cathode" with "cargo". The first two letters match.
In the third character position, t comes after r, so the string "cathode" comes after
"cargo" in lexicographic ordering. (See Figure 3.)
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/27.png</image>
			</page>
			<page title = "Relational Operator Tbl.">
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/28.png</image>
			</page>
			<page title = "Common Relational Errors">
				<text>
Common Error 5.2: Using == to Compare Strings

It is an extremely common error in Java to write == when equals is intended.
This is particularly true for strings. If you write

if (nickname == "Rob")

then the test succeeds only if the variable nickname refers to the exact same string object as the
string constant "Rob". For efficiency, Java makes only one string object for every string constant.
Therefore, the following test will pass:

String nickname = "Rob";
. . .
if (nickname == "Rob") //Test is true

However, if the string with the letters R o b 
has been assembled in some other way, then the test will fail:

String name = "Robert";
String nickname = name.substring(0, 3);
. . .
if (nickname == "Rob") // Test is false

This is a particularly distressing situation: The wrong code will sometimes do the right thing,
sometimes the wrong thing. Because string objects are always constructed by the compiler,
you never have an interest in whether two string objects are shared. You must remember
never to use == to compare strings. Always use equals or compareTo to compare strings.

5.2.4 Comparing Objects

If you compare two object references with the == operator, you test whether the references
refer to the same object. Here is an example:

Rectangle box1 = new Rectangle(5, 10, 20, 30);
Rectangle box2 = box1;
Rectangle box3 = new Rectangle(5, 10, 20, 30);

The comparison

box1 == box2

is true. Both object variables refer to the same object. But the comparison

box1 == box3

is false. The two object variables refer to different objects (see Figure 4). It does not
matter that the objects have identical contents.
You can use the equals method to test whether two rectangles have the same contents, that is,
whether they have the same upper-left corner and the same width and height. For example, the test

box1.equals(box3)

is true.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Object%20and%20Object%20Comparison/30.png</image>
				<text>
However, you must be careful when using the equals method. It works correctly
only if the implementors of the class have supplied it. The Rectangle class has an
equals method that is suitable for comparing rectangles.
For your own classes, you need to supply an appropriate equals method. You will
learn how to do that later on. Until that point, you should not use the equals
method to compare objects of your own classes.

5.2.5 Testing for null

An object reference can have the special value null if it refers to no object at all. It is
common to use the null value to indicate that a value has never been set. For example,

String middleInitial = null; // Not set
if ( . . . )
middleInitial = middleName.substring(0, 1);

You use the == operator (and not equals) to test whether an object reference is a null
reference:
if (middleInitial == null)
System.out.println(firstName + " " + lastName);
else
System.out.println(firstName + " " + middleInitial + ". " + lastName);

Note that the null reference is not the same as the empty string "". The empty string
is a valid string of length 0, whereas a null indicates that a string variable refers to no
string at all.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. What is the value of s.length() if s is
	a. the empty string ""?
	b. the string " " containing a space?
	c. null?

2. Which of the following comparisons are syntactically incorrect? Which of them
are syntactically correct, but logically questionable?
String a = "1";
String b = "one";
double x = 1;
double y = 3 * (1.0 / 3);

	a. a == "1"
	b. a == null
	c. a.equals("")
	d. a == b
	e. a == x
	f. x == y
	g. x - y == null
	h. x.equals(y)
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Homepage/variables.png</image>
		<title>Variables</title>
		<description>Explore parameter, local, instance, and class variables</description>
		<pages>
			<page>
				<text>
You often want to store values so that you can use them at a later time.
	To remember a value, you need to hold it in a variable. A variable is a storage location in the
computer’s memory that has a type, name, and contents. For example, here we
declare three variables:

String greeting = "Hello, World!";
PrintStream printer = System.out;
int width = 20;

The first variable is called greeting. It can be used to store String values, and it is set
to the value "Hello, World!". The second variable, printer, stores a PrintStream value,
and the third stores an integer.
Variables can be used in place of the values that they store:
printer.println(greeting); // Same as System.out.println("Hello, World!")
printer.println(width); // Same as System.out.println(20)

When you declare your own variables, you need to make two decisions.
• What type should you use for the variable?
• What name should you give the variable?
The type depends on the intended use. If you need to store a string, use the String
type for your variable. If you need a number, choose the int or double type.
It is an error to store a value whose type does not match the type of the variable.
For example, the following is an error:
String greeting = 20; // ERROR: Types don’t match
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/2.png</image>
				<text>
You cannot use a String variable to store an integer. The compiler checks type
mismatches to protect you from errors.
When deciding on a name for a variable, you should make a choice that describes
the purpose of the variable. For example, the variable name greeting is a better
choice than the name g.

An identifier is the name of a variable, method, or class. Java imposes the following rules for identifiers:

• Identifiers can be made up of letters, digits, and the underscore (_) and dollar sign
  ($) characters. They cannot start with a digit, though.
• You cannot use spaces or symbols such as ? or %.
• Furthermore, you cannot use reserved words, such as public, as names; these
  words are reserved exclusively for their special Java meanings. (See Appendix C
  for all reserved words in Java.)

These are firm rules of the Java language. If you violate one of them, the compiler
will report an error. Moreover, there are a couple of conventions that you should
follow so that other programmers will find your programs easy to read:

• Variable and method names should start with a lowercase letter. It is OK to use
  an occasional uppercase letter, such as farewellMessage. This mixture of lowercase
  and uppercase letters is sometimes called “camel case” because the uppercase letters
  stick out like the humps of a camel.
• Class names should start with an uppercase letter. For example, Greeting would
  be an appropriate name for a class, but not for a variable.
• You should not use the $ symbol in names. It is intended for names that are
  automatically generated by tools.

If you violate these conventions, the compiler won’t complain, but you will confuse
other programmers who read your code.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/4.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/5.png</image>
				<text>
Table 3 shows examples of legal and illegal variable names in Java.
				</text>
			</page>
			<page title = "Self Check">
				<text>
SELF CHECK

1. Which of the following are legal identifiers?

Greeting1
g
void
101dalmatians
#Hello, World

2. Declare a variable to hold your name. Use camel case in the variable name.
				</text>
			</page>
			<page title="Tip: Variable Names">
				<text>
Quality Tip 2.1

--Choose Descriptive Names for Variables--

In algebra, variable names are usually just one letter long, such as p or A,
maybe with a subscript such as p1. You might be tempted to save yourself a
lot of typing by using short variable names in your Java programs:
int A = w * h;

Compare this with the following statement:
int area = width * height;

The advantage is obvious. Reading width is much easier than reading w and then figuring out
that it must mean “width”.
In practical programming, descriptive variable names are particularly important when
programs are written by more than one person. It may be obvious to you that w stands for
width, but is it obvious to the person who needs to update your code years later? For that
matter, will you yourself remember what w means when you look at the code a month from
now?
				</text>
			</page>
			<page title="Objects">
				<text>
You learned how to use objects from existing classes. In this chapter,
you will start implementing your own classes. We begin with a very simple example
that shows you how objects store their data, and how methods access the data of an
object. You will then learn a systematic process for implementing classes.
Our first example is a class that models a tally counter, a mechanical device that is
used to count people—for example, to find out how many people attend a concert
or board a bus (see Figure 1).
Whenever the operator pushes a button, the counter value advances by one. We
model this operation with a count method. A physical counter has a display to show
the current value. In our simulation, we use a getValue method instead. For example,

Counter tally = new Counter();
tally.count();
tally.count();
int result = tally.getValue(); // Sets result to 2

When implementing the Counter class, we need to determine the data that each
counter object contains. In this simple example, that is very straightforward. Each
counter needs to store a variable that keeps track of how many times the counter
has been advanced.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/8.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/9.png</image>
				<text>
					An object stores its data in instance variables. An instance of a class is an object
					of the class. Thus, an instance variable is a storage location that is present in each
					object of the class.
					You specify instance variables in the class declaration:

					public class Counter
					{
					private int value;
					. . .
					}

An instance variable declaration consists of the following parts:
• An access specifier (private)
• The type of the instance variable (such as int)
• The name of the instance variable (such as value)

Each object of a class has its own set of instance variables. For example,
if concertand boardingCounter are two objects of the Counter class, then each object has
its own value variable (see Figure 2). As you will see in the future, the instance
variable value is set to 0 when a Counter object is constructed.
In order to gain a better understanding of how methods affect instance variables,
we will have a quick look at the implementation of the methods of the Counter class.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/11.png</image>
				<text>
The count method advances the counter value by 1. We will cover the syntax of the
method header in another section. For now, focus on the body of the method inside the
braces:
public void count()
{
value = value + 1;
}

Note how the count method accesses the instance variable value. Which instance
variable? The one belonging to the object on which the method is invoked. For
example, consider the call
concertCounter.count();

This call advances the value variable of the concertCounter object.
The getValue method returns the current value:
public int getValue()
{
return value;
}

The return statement is a special statement that terminates the method call and
returns a result to the method’s caller.
Instance variables are generally declared with the access specifier private. That
specifier means that they can be accessed only by the methods of the same class, not
by any other method. For example, the value variable can be accessed by the count
and getValue methods of the Counter class but not a method of another class. Those
other methods need to use the Counter class methods if they want to manipulate a
counter’s value.
In the next section, we discuss the reason for making instance variables private.
				</text>
			</page>
			<page title="Self Check">
				<text>
SELF CHECK

1. Supply the body of a method public void reset() that resets the counter back to
zero.
2. Suppose you use a class Clock with private instance variables hours and minutes.
How can you access these variables in your program?
				</text>
			</page>
			<page title="Local and Parameter Variables">
				<text>
In this section, we discuss the behavior of local variables. A local variable
is a variable that is declared in the body of a method. For example, the giveChange method in
declares a local variable change:
public double giveChange()
{
double change = payment - purchase;
purchase = 0;
payment = 0;
return change;
}

Parameter variables are similar to local variables, but they are declared in method
headers. For example, the following method declares a parameter variable amount:

public void enterPayment(double amount)

Local and parameter variables belong to methods. When a method runs, its local
and parameter variables come to life. When the method exits, they are removed
immediately. For example, if you call register.giveChange(), then a variable change is
created. When the method exits, that variable is removed.
In contrast, instance variables belong to objects, not methods. When an object is
constructed, its instance variables are created. The instance variables stay alive until
no method uses the object any longer. (The Java virtual machine contains an agent
called a garbage collector that periodically reclaims objects when they are no
longer used.)
An important difference between instance variables and local variables is initialization.
You must initialize all local variables. If you don’t initialize a local variable,
the compiler complains when you try to use it. (Note that parameter variables are
initialized when the method is called.)
Instance variables are initialized with a default value before a constructor is
invoked. Instance variables that are numbers are initialized to 0. Object references
are set to a special value called null. If an object reference is null, then it refers to no
object at all. We will discuss the null value in greater detail in Section 5.2.5.
				</text>
			</page>
			<page title="Self Check">
				<text>
SELF CHECK

1. What do local variables and parameter variables have in common? In which
essential aspect do they differ?
2. Why was it necessary to introduce the local variable change in the giveChange
method? That is, why didn’t the method simply end with the statement:

return payment - purchase;

				</text>
			</page>
			<page title="Implicit Parameters">
				<text>
In a previous section, you learned that a method has an implicit parameter (the object on
which the method is invoked) in addition to the explicit parameters, which are
enclosed in parentheses. In this section, we will examine implicit parameters in
greater detail.

Have a look at a particular invocation of the deposit method:

momsSavings.deposit(500);

Here, the implicit parameter is momsSavings and the explicit parameter is 500.
Now look again at the code of the deposit method:

public void deposit(double amount)
{
balance = balance + amount;
}

What does balance mean exactly? After all, our program may have multiple
Bank-Account objects, and each of them has its own balance.
Of course, since we are depositing the money into momsSavings, balance must mean
momsSavings.balance. In general, when you refer to an instance variable inside a
method, it means the instance variable of the implicit parameter.
If you need to, you can access the implicit parameter—the object on which the
method is called—with the reserved word this. For example, in the preceding
method invocation, this refers to the same object as momsSavings (see Figure 6).
The statement

balance = balance + amount;

actually means
this.balance = this.balance + amount;
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/14.png</image>
			</page>
			<page title="Instance Variables">
				<text>
When you refer to an instance variable in a method, the compiler automatically
applies it to the this reference. Some programmers actually prefer to manually
insert the this reference before every instance variable because they find it makes
the code clearer. Here is an example:

public BankAccount(double initialBalance)
{
this.balance = initialBalance;
}

You may want to try it out and see if you like that style.
The this reference can also be used to distinguish between instance variables and
local or parameter variables. Consider the constructor

public BankAccount(double balance)
{
this.balance = balance;
}

The expression this.balance clearly refers to the balance instance variable. However,
the expression balance by itself seems ambiguous. It could denote either the parameter
variable or the instance variable. In Java, local and parameter variables are considered
first when looking up variable names. Therefore,

this.balance = balance;

means: “Set the instance variable balance to the parameter variable balance”.
There is another situation in which it is important to understand the implicit
parameter. Consider the following modification to the BankAccount class. We add a
method to apply the monthly account fee:

public class BankAccount
{
. . .
public void monthlyFee()
{
withdraw(10); // Withdraw $10 from this account
}
}

That means to withdraw from the same bank account object that is carrying out the
monthlyFee operation. In other words, the implicit parameter of the withdraw method
is the (invisible) implicit parameter of the monthlyFee method.
If you find it confusing to have an invisible parameter, you can use
the this reference to make the method easier to read:

public class BankAccount
{
. . .
public void monthlyFee()
{
this.withdraw(10); // Withdraw $10 from this account
}
}

You have now seen how to use objects and implement classes, and you have learned
some important technical details about variables and method parameters. The
remainder of this chapter continues the optional graphics track. In the next chapter,
you will learn more about the most fundamental data types of the Java language.
				</text>
			</page>
			<page title="Self Check">
				<text>
SELF CHECK

1. How many implicit and explicit parameters does the withdraw method of the
BankAccount class have, and what are their names and types?
2. In the deposit method, what is the meaning of this.amount? Or, if the expression
has no meaning, why not?
3. How many implicit and explicit parameters does the main method of the
	BankAccountTester class have, and what are they called?

				</text>
			</page>
			<page title="Static Variables">
				<text>
Sometimes, a value properly belongs to a class, not to any object of the class. You
use a static variable for this purpose. Here is a typical example. We want to assign
bank account numbers sequentially. That is, we want the bank account constructor
to construct the first account with number 1001, the next with number 1002, and so
on. Therefore, we must store the last assigned account number somewhere.
Of course, it makes no sense to make this value into an instance variable:
public class BankAccount
{
private double balance;
private int accountNumber;
private int lastAssignedNumber = 1000; // NO—won’t work
. . .
}

In that case each instance of the BankAccount class would have its own value of lastAssignedNumber.

Instead, we need to have a single value of lastAssignedNumber that is the same for
the entire class. Such a variable is called a static variable, because you declare it using
the static reserved word.
public class BankAccount
{
private double balance;
private int accountNumber;
private static int lastAssignedNumber = 1000;
. . .
}

Every BankAccount object has its own balance and accountNumber instance variables, but
there is only a single copy of the lastAssignedNumber variable (see Figure 4). That
variable is stored in a separate location, outside any BankAccount objects.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/17.png</image>
				<text>
A static variable is sometimes called a class variable because there is a single variable for the entire class.
Every method of a class can access its static variables. Here is the constructor of
the BankAccount class, which increments the last assigned number and then uses it to
initialize the account number of the object to be constructed:
public class BankAccount
{
. . .
public BankAccount()
{
lastAssignedNumber++; // Updates the static variable
accountNumber = lastAssignedNumber; // Sets the instance variable
}
}

There are three ways to initialize a static variable:

1. Do nothing. The static variable is then initialized with 0 (for numbers), false
(for boolean values), or null (for objects).
2. Use an explicit initializer, such as
public class BankAccount
{
private static int lastAssignedNumber = 1000;
. . .
}
3. Use a static initialization block (see Special Topic 8.4 on page 347).

Like instance variables, static variables should always be declared as private to
ensure that methods of other classes do not change their values. The exception to
this rule are static constants, which may be either private or public. For example, the
BankAccount class may want to declare a public constant value, such as
public class BankAccount
{
public static final double OVERDRAFT_FEE = 29.95;
. . .
}

Methods from any class can refer to such a constant as BankAccount.OVERDRAFT_FEE.
It makes sense to declare constants as static—you wouldn’t want every object of
the BankAccount class to have its own set of variables with these constant values. It is
sufficient to have one set of them for the class.
Why are class variables called static? As with static methods, the static reserved
word itself is just a meaningless holdover from C++. But static variables and static
methods have much in common: They apply to the entire class, not to specific
instances of the class.
In general, you want to minimize the use of static methods and variables. If you
find yourself using lots of static methods that access static variables, then that’s an
indication that you have not found the right classes to solve your problem in an
object-oriented way.
				</text>
			</page>
			<page title="Self Check">
				<text>
SELF CHECK

1. Name two static variables of the System class.
2. Harry tells you that he has found a great way to avoid those pesky objects: Put
all code into a single class and declare all methods and variables static. Then
main can call the other static methods, and all of them can access the static
variables. Will Harry’s plan work? Is it a good idea?
				</text>
			</page>
			<page title="Scope">
				<text>
The scope of a variable is the part of the program in which the variable can be
accessed. It is considered good design to minimize the scope of a variable. This
reduces the possibility of accidental modification and name conflicts.
In the following sections, you will learn how to determine the scopes of local and
instance variables, and how to resolve name conflicts if the scopes overlap.

The scope of a local variable extends from the point of its declaration to the end of
the block or for loop that encloses it. The scope of a parameter variable is the entire
method.

public static void process(double[] values) // values is a parameter variable
{
for (int i = 0; i &lt; 10; i++) // i is a local variable declared in a for loop
{
if (values[i] == 0)
{
double r = Math.random(); // r i s a local variable declared in a block
values[i] = r;
} // Scope of r ends here
} // Scope of i ends here
} // Scope of values ends here

In Java, the scope of a local variable can never contain the declaration of another
local variable with the same name. For example, the following is an error:
public static void main(String[] args)
{
double r = Math.random();
if (r > 0.5)
{
Rectangle r = new Rectangle(5, 10, 20, 30);
// Error—can’t declare another variable called r here
. . .
}
}

However, you can have local variables with identical names if their scopes do not
overlap, such as
if (Math.random() > 0.5)
{
Rectangle r = new Rectangle(5, 10, 20, 30);
. . .
} // Scope of r ends here
else
{
int r = 5;
// OK—it is legal to declare another r here
. . .
}

These variables are independent from each other, or, in other words, their scopes are
disjoint. You can have local variables with the same name r in different methods,
just as you can have different motels with the same name “Bates Motel” in different
cities.
In contrast, the scope of instance variables and static variables consists of the
entire class in which they are declared.

Problems arise if you have two identical variable names with overlapping scope.
This can never occur with local variables, but the scopes of identically named local
variables and instance variables can overlap. Here is a purposefully bad example.
public class Coin
{
private String name;
private double value; // Instance variable
. . .
public double getExchangeValue(double exchangeRate)
{
double value; // Local variable with the same name
. . .
return value;
}
}

Inside the getExchangeValue method, the variable name value could potentially have
two meanings: the local variable or the instance variable. The Java language
specifies that in this situation the local variable wins out. It shadows the instance variable.

This sounds pretty arbitrary, but there is actually a good reason: You can still refer
to the instance variable as this.value.
value = this.value * exchangeRate;

Of course, it is not a good idea to write code like this. You can easily change the
name of the local variable to something else, such as result.
However, there is one situation where overlapping scope is acceptable. When
implementing constructors or setter methods, it can be awkward to come up with
different names for instance variables and parameters. Here is how you can use the
same name for both:
public Coin(double value, String name)
{
this.value = value;
this.name = name;
}

The expression this.value refers to the instance variable, and value is the parameter.
				</text>
			</page>
			<page title="Self Check">
				<text>
SELF CHECK

1. Consider the following program that uses two variables named r. Is this legal?
public class RectangleTester
{
public static double area(Rectangle rect)
{
double r = rect.getWidth() * rect.getHeight();
return r;
}
public static void main(String[] args)
{
Rectangle r = new Rectangle(5, 10, 20, 30);
double a = area(r);
System.out.println(r);
}
}

2. What is the scope of the balance variable of the BankAccount class?
				</text>
			</page>
			<page title="Tips and Errors: Shadowing">
				<text>
Common Error: Shadowing
Accidentally using the same name for a local variable and an instance variable
is a surprisingly common error. As you saw in the preceding section, the local variable then shadows the
instance variable. Even though you may have meant to access the instance variable, the local
variable is quietly accessed. Look at this example of an incorrect constructor:
public class Coin
{
private double value;
private String name;
. . .
public Coin(double aValue, String aName)
{
value = aValue;
String name = aName; // Oops . . .
}
}

The programmer declared a local variable name in the constructor. In all likelihood, that was
just a typo—the programmer’s fingers were on autopilot and typed the reserved word String,
even though the programmer all the time intended to access the instance variable. Unfortunately, the compiler gives no warning in this situation and quietly sets the local variable to
the value of aName. The instance variable of the object that is being constructed is never
touched, and remains null.
Some programmers give all instance variable names a special prefix to distinguish them
from other variables. A common convention is to prefix all instance variable names with the
prefix my, such as myValue or myName.
Another way of avoiding this problem is to use the this parameter when accessing an
instance variable:
this.name = aName;

Quality Tip: Minimize Variable Scope

When you make the scope of a variable as small as possible, it becomes less likely that the
variable is accidentally corrupted. It also becomes easier to modify or eliminate the variable
as you reorganize your code.
As already mentioned, don’t make an instance variable public. (The Java library has a few
classes with public instance variables, but their creators later regretted their decision when
they were unable to make optimizations later.)
When you have a constant, ask yourself who needs it. Everybody (public static final )?
Only the class (private static final )? Only a single method (a final local variable)? Choose
the smallest scope.
Beware of unnecessary instance variables. For example, consider the Pyramid class in
Worked Example 4.1. You would not want an instance variable for the volume:
public class Pyramid
{
private double height;
private double baseLength;
private double volume; // Not
. . .
}

a good idea to use class scope for this variable

Instead, compute the volume when it is needed in the getVolume method. That way, no other
method can accidentally modify the volume variable, or forget to modify it when changing the
height or base length.
Finally, with local variables, declare them only when you need them.
				</text>
			</page>
			<page title="Parameter Variables">
				<text>
Methods are fundamental building blocks of Java programs. A program performs
useful work by calling methods. In this section, we will examine how to provide
inputs into a method, and how to obtain the result of the method.
Most methods require inputs that give details about the work that the method
needs to do. For example, the println method has an input: the string that should be
printed. Computer scientists use the technical term parameter for method inputs.
We say that the string greeting is a parameter of the method call
System.out.println(greeting);

Figure 6 illustrates passing of the parameter to the method.
Technically speaking, the greeting parameter is an explicit parameter of the
println method. The object on which you invoke the method is also considered a
parameter of the method call; it is called the implicit parameter. For example,
System.out is the implicit parameter of the method call

System.out.println(greeting);

Some methods require multiple explicit parameters, others don’t require any
explicit parameters at all. An example of the latter is the length method of the String
class (see Figure 7). All the information that the length method requires to do its
job—namely, the character sequence of the string—is stored in the implicit parameter object.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/20.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/21.png</image>
				<text>
The length method differs from the println method in another way: it has an
output. We say that the method returns a value, namely the number of characters in the
string. You can store the return value in a variable:
int n = greeting.length();

You can also use the return value as a parameter of another method:
System.out.println(greeting.length());

The method call greeting.length() returns a value—the integer 13. The return value
becomes a parameter of the println method. Figure 8 shows the process.
Not all methods return values. One example is the println method. The println
method interacts with the operating system, causing characters to appear
in a window. But it does not return a value to the code that calls it.
Let us analyze a more complex method call. Here, we will call the replace method
of the String class. The replace method carries out a search-and-replace operation,
similar to that of a word processor. For example, the call

river.replace("issipp", "our")

constructs a new string that is obtained by replacing all occurrences of "issipp" in
"Mississippi" with "our". (In this situation, there was only one replacement.) The
method returns the String object "Missouri". You can save that string in a variable:
river = river.replace("issipp", "our");

Or you can pass it to another method:
System.out.println(river.replace("issipp", "our"));
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/23.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Variables/24.png</image>
				<text>

As Figure 9 shows, this method call has
• one implicit parameter: the string "Mississippi"
• two explicit parameters: the strings "issipp" and "our"
• a return value: the string "Missouri"
When a method is declared in a class, the declaration specifies the types of the
explicit parameters and the return value. For example, the String class declares the
length method as

public int length()

That is, there are no explicit parameters, and the return value has the type int. (For
now, all the methods that we consider will be “public” methods—see Chapter 10
for more restricted methods.)
The type of the implicit parameter is the class that declares the method—String in
our case. It is not mentioned in the method declaration—hence the term “implicit”.
The replace method is declared as

public String replace(String target, String replacement)

To call the replace method, you supply two explicit parameters, target
and replacement, which both have type String. The returned value is another string.
When a method returns no value, the return type is declared with the reserved
word void. For example, the PrintStream class declares the println method as

public void println(String output)

				</text>
			</page>
			<page title="Self Check">
				<text>
SELF CHECK

1. What are the implicit parameters, explicit parameters, and return values in the method call river.length()?
2. What is the result of the call river.replace("p", "s")?
3. What is the result of the call greeting.replace("World", "Dave").length() ?
4. How is the toUpperCase method declared in the String class?
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Homepage/methods.png</image>
		<title>Methods</title>
		<description>Learn about public, private, and static methods. Also, consider overloading, parameter passing, and overriding.</description>
		<pages>
			<page >
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Methods/0.png</image>
				<text>
Imagine that you are a member of a team that works on banking software. A
fundamental concept in banking is a bank account. Your task is to understand the
design of a BankAccount class so that you can implement it, which in turn allows other
programmers on the team to use it.

You need to know exactly what features of a bank account need to be implemented.
Some features are essential (such as deposits), whereas others are not
important (such as the gift that a customer may receive for opening a bank account).
Deciding which features are essential is not always an easy task. We will revisit that
issue in later chapters. For now, we will assume that a competent designer has
decided that the following are considered the essential operations of a bank account:
• Deposit money
• Withdraw money
• Get the current balance
In Java, operations are expressed as method calls. To figure out the exact specification
of the method calls, imagine how a programmer would carry out the bank
account operations. We’ll assume that the variable harrysChecking contains a reference
to an object of type BankAccount. We want to support method calls such as the following:

harrysChecking.deposit(2240.59);
harrysChecking.withdraw(500);
double currentBalance = harrysChecking.getBalance();

The first two methods are mutators. They modify the balance of the bank account
and don’t return a value. The third method is an accessor. It returns a value that you
store in a variable or pass to a method.
As you can see from the sample calls, the BankAccount class should declare three
methods:
• public void deposit(double amount)
• public void withdraw(double amount)
• public double getBalance()

Recall from before that double denotes the double-precision floating-point type,
and void indicates that a method does not return a value.
Here we only give the method headers. When you declare a method, you also
need to provide the method body, consisting of statements that are executed when
the method is called.
public void deposit(double amount)
{

implementation—filled in later
}


We will supply the method bodies in a later section.
Every method header contains the following parts:

• An access specifier (usually public)
• The return type (the type of the value returned, such as void or double)
• The name of the method (such as deposit)
• A list of the parameter variables of the method (if any), enclosed in parentheses
(such as double amount)

The access specifier controls which other methods can call this method. Most methods
should be declared as public. That way, all other methods in a program can call
them. (Occasionally, it can be useful to have private methods. They can only be
called from other methods of the same class.)

The return type is the type of the value that the method returns. The deposit
method does not return a value, whereas the getBalance method returns a value of
type double.
Each parameter of the method has both a type and a name that describes its purpose.
For example, the deposit method has a single parameter named amount of type double.
Next, you need to supply constructors. A constructor initializes the instance
variables of an object. In Java, a constructor is very similar to a method, with two
important differences.
• The name of the constructor is always the same as the name of the class (e.g.,
BankAccount).
• Constructors have no return type (not even void).
We want to construct bank accounts that initially have a zero balance, as well as
accounts that have a given initial balance. For this purpose, we specify two constructors.

• public BankAccount()
• public BankAccount(double initialBalance)

They are used as follows:
BankAccount harrysChecking = new BankAccount();
BankAccount momsSavings = new BankAccount(5000);

Just like a method, a constructor also has a body—a sequence of statements that is
executed when a new object is constructed.
public BankAccount()
{

implementation—filled in later
}

Don’t worry about the fact that there are two constructors with the same name—
all constructors of a class have the same name, that is, the name of the class. The
compiler can tell them apart because they take different parameters.
When declaring a class, you place all constructor and method declarations inside,
like this:
public class BankAccount
{

private instance variables—filled in later
// Constructors
public BankAccount()
{

implementation—filled in later
}
public BankAccount(double initialBalance)
{

implementation—filled in later
}

// Methods
public void deposit(double amount)
{

implementation—filled in later
}
public void withdraw(double amount)
{

implementation—filled in later
}
public double getBalance()
{

implementation—filled in later
}
}

The public constructors and methods of a class form the public interface of the
class. These are the operations that any programmer can use to create and manipulate BankAccount objects.
Our BankAccount class is simple, but it allows programmers to carry out all of the
important operations that commonly occur with bank accounts. For example,
consider this program segment, authored by a programmer who uses the BankAccount
class. These statements transfer an amount of money from one bank account to
another:
// Transfer from one account to another
double transferAmount = 500;
momsSavings.withdraw(transferAmount);
harrysChecking.deposit(transferAmount);

And here is a program segment that adds interest to a savings account:
double interestRate = 5; // 5% interest
double interestAmount
= momsSavings.getBalance() * interestRate / 100;
momsSavings.deposit(interestAmount);
				</text>
			</page>
			<page title="Static Methods">
				<text>
Java contains a Math class, which contains a collection
of helpful methods for carrying out mathematical computations. These methods
have a special form: they are static methods that do not operate on an object.
That is, you don’t call

double root = 100.sqrt(); // Error

In Java, numbers are not objects, so you can never invoke a method on a number.
Instead, you pass a number as an explicit parameter to a method, enclosing the
number in parentheses after the method name:

double root = Math.sqrt(100);
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Methods/2.png</image>
				<text>
This call makes it appear as if the sqrt method is applied to an object called Math.
However, Math is a class, not an object. A method such as Math.sqrt that does not
operate on any object is called a static method. (The term “static” is a historical
holdover from the C and C++ programming languages. It has nothing to do with
the usual meaning of the word.) In contrast, a method that is invoked on an object is
class, is called an instance method:

harrysChecking.deposit(100); // deposit is an instance method

Static methods do not operate on objects, but they are still declared inside classes.
When calling the method, you specify the class to which the sqrt method belongs—
hence the call is Math.sqrt(100).
How can you tell that Math is a class and not an object? By convention, class
names start with an uppercase letter (such as Math or BankAccount). Objects and
methods start with a lowercase letter (such as harrysChecking and println). Therefore,
harrysChecking.deposit(100) denotes a call of the deposit method on the harrysChecking
object inside the System class. On the other hand, Math.sqrt(100) denotes a call to the
sqrt method inside the Math class.
This use of upper- and lowercase letters is merely a convention, not a rule of the
Java language. It is, however, a convention that the authors of the Java class libraries
follow consistently. You should do the same in your programs so that you don’t
confuse your fellow programmers.
				</text>
			</page>
			<page title="Self Check">
				<text>
SELF CHECK

1. Why can’t you call x.pow(y) to compute x^y?
2. Is the call System.out.println(4) a static method call?

				</text>
			</page>
			<page title="Overriding Methods">
				<text>
A subclass method overrides a superclass method if it has the same name and
parameter types as a superclass method. When such a method is applied to a
subclass object, the overriding method, and not the original method, is executed.
We turn to the CheckingAccount class for an example of overriding methods. Recall
that the BankAccount class has three methods:
public class BankAccount
{
. . .
public void deposit(double amount) { . . . } \\ this method overrides a BankAccount method
public void withdraw(double amount) { . . . } \\ this method overrides a BankAccount method
public double getBalance() { . . . }
}

The CheckingAccount class declares these methods:
public class CheckingAccount extends BankAccount
{
. . .
public void deposit(double amount) { . . . }
public void withdraw(double amount) { . . . }
public void deductFees() { . . . }
}

These methods override
BankAccount methods.

The deposit and withdraw methods of the CheckingAccount class override the deposit
and withdraw methods of the BankAccount class to handle transaction fees. However,
the deductFees method does not override another method, and the getBalance method
is not overridden.
				</text>
			</page>
			<page title="Overloaded Methods">
				<image>https://res.cloudinary.com/ianspryn/image/upload/Magis/Methods/5.png</image>
				<text>
Let’s implement the deposit method of the CheckingAccount class. It increments the
transaction count and deposits the money:
public class CheckingAccount extends BankAccount
{
. . .
public void deposit(double amount)
{
transactionCount++;
// Now add amount to balance
. . .
}
}

Now we have a problem. We can’t simply add amount to balance:
public class CheckingAccount extends BankAccount
{
. . .
public void deposit(double amount)
{
transactionCount++;
// Now add amount to balance
balance = balance + amount; // Error
}
}

Although every CheckingAccount object has a balance instance variable, that instance
variable is private to the superclass BankAccount. Subclass methods have no more
access rights to the private data of the superclass than any other methods. If you
want to modify a private superclass instance variable, you must use a public method
of the superclass.

How can we add the deposit amount to the balance, using the public interface of
the BankAccount class? There is a perfectly good method for that purpose—namely,
the deposit method of the BankAccount class. So we must invoke the deposit method
on some object. On which object? The checking account into which the money is
deposited—that is, the implicit parameter of the deposit method of the
CheckingAccount class. To invoke another method on the implicit parameter,
you don’t specify the parameter but simply write the method name, like this:

public class CheckingAccount extends BankAccount
{
public void deposit(double amount)
{
transactionCount++;
// Now add amount to balance
deposit(amount); // Not complete
}
. . .
}

But this won’t quite work. The compiler interprets
deposit(amount);

as
this.deposit(amount);

The this parameter is of type CheckingAccount. There is a method called deposit in the
CheckingAccount class. Therefore, that method will be called—but that is just the
method we are currently writing! The method will call itself over and over, and the
program will die in an infinite recursion (discussed in Chapter 13).
Instead, we must be specific that we want to invoke only the superclass’s deposit
method. There is a special reserved word super for this purpose:
public class CheckingAccount extends BankAccount
{
public void deposit(double amount)
{
transactionCount++;
// Now add amount to balance
super.deposit(amount);
}
. . .
}

This version of the deposit method is correct. To deposit money into a checking
account, update the transaction count and call the deposit method of the superclass.
The remaining methods of the CheckingAccount class also invoke a superclass method.
public class CheckingAccount extends BankAccount
{
private static final int FREE_TRANSACTIONS = 3;
private static final double TRANSACTION_FEE = 2.0;
private int transactionCount;
. . .
public void withdraw(double amount)
{
transactionCount++;
// Now subtract amount from balance
super.withdraw(amount);
}
public void deductFees()
{
if (transactionCount > FREE_TRANSACTIONS)
{
double fees = TRANSACTION_FEE * (transactionCount - FREE_TRANSACTIONS);
super.withdraw(fees);
}
transactionCount = 0;
}
. . .
}
				</text>
			</page>
			<page title="Self Check">
				<text>
SELF CHECK

1. Categorize the methods of the SavingsAccount class as inherited, new, and overridden.
2. Why does the withdraw method of the CheckingAccount class call super.withdraw?
3. Why does the deductFees method set the transaction count to zero?
				</text>
			</page>
			<page title="Accidental Overloading">
				<text>
Recall from before that two methods can have the same name, provided they have different
method parameters. For example, the PrintStream class has methods called println with headers

void println(int x)

and

void println(String x)

These are different methods, each with its own implementation. The Java compiler considers
them to be completely unrelated. We say that the println name is overloaded. This is different
from overriding, where a subclass method provides an implementation of a method with
the same method parameters.

If you mean to override a method but supply a different parameter type, then you
accidentally introduce an overloaded method. For example,
public class CheckingAccount extends BankAccount
{
. . .
public void deposit(int amount) // Error: should
{
. . .
}
}

be double

The compiler will not complain. It thinks that you want to provide a deposit method just for
int parameters, while inheriting another deposit method for double parameters.
When overriding a method, be sure to check that the parameter types match exactly.
				</text>
			</page>
		</pages>
	</chapter>
</lesson>