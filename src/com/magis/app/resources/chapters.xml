<?xml version = "1.0"?>
<!--
STRUCTURE:

<lesson>
	<chapter>
		<image></image>
		<title></title>
		<description>
		<pages>
			<page>
				<text></text>
				<image></image>
			</page>
		</pages>
	</chapter>
</lesson>

-->

<!--
FORMATTING:

Format as code:
	```
	int myVariable = 2;
	```

Format as code output or special text:
	###
	the answer is 3
	###

Format as H1 header:
	[H1]My Title[H1]

Format as H2 header:
	[H2]My Subtitle[H2]

Format as H3 header:
	[H3]My Sub-subtitle[H3]

-->
<lesson>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/comments.png</image>
		<title>Comments</title>
		<description>Become familiar with the three types of Java comments</description>
		<pages>
			<page>
				<text>
This line inside the main method is a comment:
```
// Display a greeting in the console window
```
This comment is purely for the beneﬁt of the human reader, to explain in more detail what the next statement does. Any text enclosed between // and the end of the line is completely ignored by the compiler. Comments are used to explain the program to other programmers or to yourself.

There are three kinds of comments:
```
/* comment */
// one-line-comment
/** documentationComment */
```
The one-line comment extends to the end of the line. The other comments can span multiple lines and extend to the */ delimiter.

A documentation comment is delimited by /** and */. You can comment the following:

	• Classes
	• Methods
	• Instance variables

Each comment is placed immediately above the feature it documents. Each /** . . . */ documentation comment contains introductory text followed by tagged documentation.
				</text>
			</page>
			<page title = "Public Interfaces">
				<text>
When you implement classes and methods, you should get into the habit of thoroughly commenting their behaviors. In Java there is a very useful standard form for documentation comments. If you use this form in your classes, a program called javadoc can automatically generate a neat set of HTML pages that describe them. A documentation comment is placed before the class or method declaration that is being documented. It starts with a /**, a special comment delimiter used by the javadoc utility. Then you describe the method’s purpose. Then, for each method parameter, you supply a line that starts with @param, followed by the parameter name and a short explanation. Finally, you supply a line that starts with @return, describing the return value. You omit the @param tag for methods that have no parameters, and you omit the @return tag for methods whose return type is void. The javadoc utility copies the first sentence of each comment to a summary table in the HTML documentation. Therefore, it is best to write that first sentence with some care. It should start with an uppercase letter and end with a period. It does not have to be a grammatically complete sentence, but it should be meaningful when it is pulled out of the comment and displayed in a summary.

Here are two typical examples.
```
/**
Withdraws money from the bank account.
@param amount the amount to withdraw
*/
public void withdraw(double amount)
{
	//implementation filled in later
}
/**
Gets the current balance of the bank account.
@return the current balance
*/
public double getBalance()
{
	//implementationfilled in later
}
```
The comments you have just seen explain individual methods. Supply a brief comment for each class, explaining its purpose. The comment syntax for class comments is very simple: Just place the documentation comment above the class.
```
/**
A bank account has a balance that can be changed by
deposits and withdrawals.
*/
public class BankAccount
{
	. . .
}
```
Your first reaction may well be “Whoa! Am I supposed to write all this stuff?” These comments do seem pretty repetitive. But you should take the time to write them, even if it feels silly.
It is always a good idea to write the method comment first, before writing the code in the method body. This is an excellent test to see that you firmly understand what you need to program. If you can’t explain what a class or method does, you aren’t ready to implement it.
What about very simple methods? You can easily spend more time pondering whether a comment is too trivial to write than it takes to write it. In practical programming, very simple methods are rare. It is harmless to have a trivial method overcommented, whereas a complicated method without any comment can cause real grief to future maintenance programmers. According to the standard Java documentation style, every class, every method, every parameter, and every return value should have a comment.
				</text>
			</page>
			<page title = "Self Check">
				<text>
1. Provide documentation comments for the Counter class of Section 3.1.

2. Suppose we enhance the BankAccount class so that each account has an account
number. Supply a documentation comment for the constructor
public BankAccount(int accountNumber, double initialBalance)

3. Why is the following documentation comment questionable?
```
/**
Each account has an account number.
@return the account number of this account
*/
public int getAccountNumber()
```
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/primitive-types.png</image>
		<title>Primitive Types</title>
		<description>Become familiar with basic programming terminology and learn about the concepts of types, variables, and assignment</description>
		<pages>
			<page>
				<text>
A computer program processes values: numbers, strings, and more complex data items. In Java, every value has a TYPE. (A type speciﬁes a set of values and  the operations that can be carried out with the values.) For example, the number 13 has the type int (an abbreviation for “integer”), "Hello, World" has the type String, and the object System.out has the type PrintStream. The type tells you what operations you can carry
out with the values. For example, you can compute the sum or product of any two integers. You can call println on any object of type PrintStream. Java has separate types for INTEGERS and FLOATING-POINT numbers. Integers are whole numbers; floating-point numbers can have fractional parts. For example, 13 is an integer and 1.3 is a floating-point number.
The name “floating-point” describes the representation of the number in the computer as a sequence of the significant digits and an indication of the position of the decimal point. For example, the numbers 13000.0, 1.3, 0.00013 all have the same decimal digits: 13. When a floating-point number is multiplied or divided by 10, only the position of the decimal point changes; it “floats”. This representation is related to the “scientific” notation 1.3 × 10^(–4). (Actually, the computer represents numbers in base 2, not base 10, but the principle is the same.)
If you need to process numbers with a fractional part, you should use the type called DOUBLE (The double type denotes ﬂoatingpoint numbers that can have fractional parts.), which stands for “double precision floating-point number”. Think of a number in double format as any number that can appear in the display panel of a calculator, such as 1.3 or –0.333333333.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Primitive%20Types/2.png</image>
			</page>
			<page>
				<text>
When a value such as 13 or 1.3 occurs in a Java program, it is called a number literal. Do not use commas when you write number literals in Java. For example, 13,000 must be written as 13000. To write numbers in exponential notation in Java, use the notation En instead of “ × 10n ”. For example, 1.3 × 10^–4 is written as 1.3E-4. Table 1 shows how to write integer and floating-point literals in Java. You may wonder why Java has separate integer and floating-point number types.
Pocket calculators don’t need a separate integer type; they use floating-point numbers for all calculations. However, integers have several advantages over floating point numbers. They take less storage space, are processed faster, and don’t cause rounding errors. You will want to use the int type for quantities that can never have fractional parts, such as the length of a string. Use the double type for quantities that
can have fractional parts, such as a grade point average. There are several other number types in Java that are not as commonly used. We
will discuss these types in Chapter 4. For most programs in this book, however, the int and double types are all you need for processing numbers.
In Java, the number types (int, double, and the less commonly used types) are primitive types. Numbers are not objects. The number types have no methods. However, you can combine numbers with operators such as + and -, as in 10 + n or n - 1. To multiply two numbers, use the * operator. For example, 10 × n is written as 10 * n. A combination of variables, literals, operators, and/or methods (which you will see in Section 2.4) is called an expression. A typical example of an expression is x + y * 2.

Numbers can be combined by arithmetic operators such as +, -, and *.

As in mathematics, the * operator binds more strongly than the + operator. That is, x + y * 2 means the sum of x and y * 2. If you want to multiply the sum of x and y by 2, use parentheses: (x + y) * 2
				</text>
			</page>
			<page title = "Self Check">
				<text>
Self Check

1. What are the types of the values 0 and "0"?

2. Which number type would you use for storing the area of a circle?

3. Why is the expression 13.println() an error?

4. Write an expression to compute the average of the values x and y.
				</text>
			</page>
			<page>
				<text>
In Java, every value is either a reference to an object, or it belongs to one of the eight primitive types shown in Table 1. Six of the primitive types are number types; four of them for integers and two for ﬂoating-point numbers.

The largest number that can be represented in an int is denoted by Integer.MAX_VALUE. Its value is about 2.14 billion. Similarly, Integer.MIN_VALUE is the smallest integer, about –2.14 billion. Generally, you will use the int type for integer quantities. However,
occasionally, calculations involving integers can overflow. This happens if the result of a computation exceeds the range for the number type. For example:
```
int n = 1000000;
System.out.println(n * n); // Prints –727379968, which is clearly wrong
```
The product n * n is 1012, which is larger than the largest integer (about 2 · 109). The result is truncated to ﬁt into an int, yielding a value that is completely wrong.

Unfortunately, there is no warning when an integer overﬂow occurs. If you run into this problem, the simplest remedy is to use the long type.

Overﬂow is not usually a problem for double-precision ﬂoating-point numbers. The double type has a range of about ±10308 and about 15 signiﬁcant digits. However, you want to avoid the float type—it has less than 7 signiﬁcant digits. (Some programmers use float to save on memory if they need to store a huge set of numbers that do not require much precision.)
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Primitive%20Types/2.png</image>
			</page>
			<page>
				<text>
Rounding errors are a more serious issue with ﬂoating-point values. Rounding errors can occur when you convert between binary and decimal numbers, or between integers and ﬂoating-point numbers. When a value cannot be converted exactly, it is rounded to the nearest match. Consider this example:
```
double f = 4.35;
System.out.println(100 * f); // Prints 434.99999999999994
```
This problem is caused because computers represent numbers in the binary number system. In the binary number system, there is no exact representation of the fraction 1/10, just as there is no exact representation of the fraction 1/3 = 0.33333 in the decimal number system. (See Special Topic 4.2 on page 130 for more information.) For this reason, the double type is not appropriate for ﬁnancial calculations. In this book, we will continue to use double values for bank balances and other ﬁnancial quantities so that we keep our programs as simple as possible. However, professional programs need to use the BigDecimal type for this purpose—see Special Topic 4.1 on page 130. In Java, it is legal to assign an integer value to a ﬂoating-point variable:
```
int dollars = 100;
double balance = dollars; // OK
```
But the opposite assignment is an error:
You cannot assign a ﬂoating-point expression to an integer variable.
```
double balance = 13.75;
int dollars = balance; // Error
```
				</text>
			</page>
			<page title = "Self Check">
				<text>
1. Which are the most commonly used number types in Java?

2. Suppose you want to write a program that works with population data from various countries. Which Java data type should you use?

3. Which of the following initializations are incorrect, and why?
	a. ```int dollars = 100.0;```
	b. ```double balance = 100;```
				</text>
			</page>
			<page>
				<text>
In Java, strings are objects that belong to the class ```String```. (You can tell that ```String``` is a class name because it starts with an uppercase letter. The primitive types int and double start with lowercase letters.) You do not need to call a constructor to create a string object. You can obtain a string literal simply by enclosing a sequence of characters in double quotation marks. For example, the string literal "Harry" is an object of the ```String``` class. The number of characters in a string is called the length of the string. As you have seen, you can use the length method to obtain the length of a string. For example, "Hello".length() is 5, and the length of "Hello, World!" is 13. (The quotation marks are not part of the string and do not contribute to the length, but you must count spaces and punctuation marks.) A string of length zero, containing no characters, is called the empty string and is written as "".
				</text>
			</page>
			<page>
				<text>
In Java, an expression such as amount &lt; 1000 has a value, just as the expression amount + 1000 has a value. The value of a relational expression is either true or false. For example, if amount is 500, then the value of amount &lt; 1000 is true. Try it out: The program fragment
```
double amount = 0;
bool lessThanThousand = amount &lt; 1000;
System.out.println(lessThanThousand);
```
prints true. The values true and false are not numbers, nor are they objects of a class. They belong to a separate type, called boolean. The Boolean type is named after the mathematician George Boole (1815–1864), a pioneer in the study of logic.
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/2-operators.png</image>
		<title>Operators</title>
		<description>Learn how to use operators to manipulate variables. From changing the values of variables to casting variables to different types, you'll understand how to control and utilize your data</description>
		<pages>
			<page title = "Assignment Operator">
				<text>
You can change the value of a variable with the assignment operator (=). For example, consider the variable declaration
```
int width = 10;
```
If you want to change the value of the variable, simply assign the new value:
```width = 20;```
The assignment replaces the original value of the variable (see Figure 1).
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/2.png</image>
			</page>
			<page title = "Assignment Errors">
				<text>
It is an error to use a variable that has never had a value assigned to it. For example,
the following assignment statement has an error:
```
int height;
width = height;

// ERROR—uninitialized variable height
```
The compiler will complain about an “uninitialized variable” when you use a
variable that has never been assigned a value. (See Figure 2.)
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/4.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/5.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/6.png</image>
			</page>
			<page title = "Good Assignment Practice">
				<text>
The remedy is to assign a value to the variable before you use it:
All variables must be initialized before you access them.
```
int height = 30;
width = height; // OK
```
Or, even better, initialize the variable when you declare it.
```
int height = 30;
int width = height; // OK
```
The right-hand side of the = symbol can be a mathematical expression. For example,
```
width = height + 10;
```
This means “compute the value of height + 10 and store that value in the variable
width”.

In the Java programming language, the = operator denotes an action, to replace the value of a variable. This usage differs from the mathematical usage of the = symbol as a statement about equality. For example, in Java, the following statement is entirely legal:
```
width = width + 10;
```
This means “compute the value of width + 10 (figure 3.1) and store that value in the variable width (figure 3.2) ” 

In Java, it is not a problem that the variable width is used on both sides of the = symbol. Of course, in mathematics, the equation width = width + 10 has no solution.
				</text>
			</page>
			<page title = "Self Check">
				<text>
1. Is 12 = 12 a valid expression in the Java language?

2. How do you change the value of the greeting variable to "Hello, Nina!"?
				</text>
			</page>
			<page title = "Variable Declarations">
				<text>
Suppose your program declares a variable as follows:
```
int width = 20;
```
If you want to change the value of the variable, you use an assignment statement:
```
width = 30;
```
It is a common error to accidentally use another variable declaration:
```
int width = 30; // ERROR—starts with int and is therefore a declaration
```
But there is already a variable named width. The compiler will complain that you are trying
to declare another variable with the same name.
				</text>
			</page>
			<page title = "Arithmetic Operators">
				<text>
Java supports the same four basic arithmetic operations as a calculator—addition, subtraction, multiplication, and division. As you have already seen, addition and subtraction use the familiar + and - operators, and the * operator denotes multiplication. Division is indicated with a /, not a fraction bar. For example,
###
a+b/2
###
becomes
###
(a + b) / 2
###
Parentheses are used just as in algebra: to indicate in which order the subexpressions should be computed. For example, in the expression (a + b) / 2, the sum a + b is computed ﬁrst, and then the sum is divided by 2. In contrast, in the expression
###
a + b / 2
###
only b is divided by 2, and then the sum of a and b / 2 is formed. Just as in regular algebraic notation, multiplication and division bind more strongly than addition and subtraction. For example, in the expression a + b / 2, the / is carried out ﬁrst, even though the + operation occurs farther to the left.

Incrementing a value by 1 is so common when writing programs that there is a special shorthand for it, namely
```
items++;
```
This statement adds 1 to items. It is easier to type and read than the equivalent assignment statement
```
items = items + 1;
```
As you might have guessed, there is also a decrement operator --. The statement
```
items--;
```
subtracts 1 from items.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/9.png</image>
			</page>
			<page title = "Arithmetic Operators">
				<text>
Division works as you would expect, as long as at least one of the numbers involved is a ﬂoating-point number. That is,
###
7.0 / 4.0
7 / 4.0
7.0 / 4
###
all yield 1.75. However, if both numbers are integers, then the result of the division is always an integer, with the remainder discarded. That is,
###
7 / 4
###
evaluates to 1, because 7 divided by 4 is 1 with a remainder of 3 (which is discarded). Discarding the remainder is often useful, but it can also be a source of subtle programming errors. If you are interested only in the remainder of an integer division, use the % operator:
###
7 % 4
###
is 3, the remainder of the integer division of 7 by 4. The % symbol has no analog in algebra. It was chosen because it looks similar to /, and the remainder operation is related to division. Here is a typical use for the integer / and % operations. Suppose you want to
know how much change a cash register should give, using separate values for dollars and cents. You can compute the value as an integer, denominated in cents, and then compute the whole dollar amount and the remaining change:
```
final int PENNIES_PER_NICKEL = 5;
final int PENNIES_PER_DIME = 10;
final int PENNIES_PER_QUARTER = 25;
final int PENNIES_PER_DOLLAR = 100;

// Compute total value in pennies
int total = dollars * PENNIES_PER_DOLLAR + quarters * PENNIES_PER_QUARTER
  + nickels * PENNIES_PER_NICKEL + dimes * PENNIES_PER_DIME + pennies;

// Use integer division to convert to dollars, cents
int dollars = total / PENNIES_PER_DOLLAR;
int cents = total % PENNIES_PER_DOLLAR;
```
For example, if total is 243, then dollars is set to 2 and cents to 43.

To compute x^n, you write ```Math.pow(x, n)```. However, to compute x^2 it is signiﬁcantly more efﬁcient simply to compute x * x. To take the square root of a number, you use the Math.sqrt method. For example, x^(1/2) is written as Math.sqrt(x). In algebra, you use fractions, superscripts for exponents, and radical signs for roots to arrange expressions in a compact two-dimensional form. In Java, you have
to write all expressions in a linear arrangement.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/11.png</image>
			</page>
			<page title = "Arithmetic Operators">
				<text>
For example, the subexpression
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/13.png</image>
				<text>
of the quadratic formula becomes
###
(-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a)
###
Figure 2 shows how to analyze such an expression. 

Table 2 shows additional methods of the Math class. Inputs and outputs are ﬂoating-point numbers.
				</text>
			</page>
			<page title = "Casting">
				<text>
Occasionally, you have a value of type double that you need to convert to the type int. Use the cast operator (int) for this purpose. You write the cast operator before the expression that you want to convert:
```
double balance = total + tax;
int dollars = (int) balance;
```
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/15.png</image>
				<text>
The cast (int) converts the ﬂoating-point value balance to an integer by discarding the fractional part. For example, if balance is 13.75, then dollars is set to 13. The cast tells the compiler that you agree to information loss, in this case, to the loss of the fractional part. You can also cast to other types, such as (float) or (byte). If you want to round a ﬂoating-point number to the nearest whole number, use the Math.round method. This method returns a long integer, because large ﬂoatingpoint numbers cannot be stored in an int.
```
long rounded = Math.round(balance);
```
				</text>
			</page>
			<page title = "Table 2">
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/17.png</image>
			</page>
			<page title = "Self Check">
				<text>
1. What is the value of ```n``` after the following sequence of statements?
```
n--;
n++;
n--;
```
2. What is the value of ###1729 / 100###? Of ###1729 % 100###?

3. Why doesn’t the following statement compute the average of ```s1```, ```s2```, and ```s3```?
```double average = s1 + s2 + s3 / 3; // Error```
4. What is the value of Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) in mathematical
notation?

5. When does the cast ```(long) x``` yield a different result from the call ```Math.round(x)```?

6. When does the cast ```(long) x``` yield a different result from the call ```Math.round(x)```?
How do you round the ```double``` value ```x``` to the nearest ```int``` value, assuming that you know that it is less than 2 · 10^9?
				</text>
			</page>
			<page title = "Strings">
				<text>
You can use the + operator to put strings together to form a longer string.
```
String name = "Dave";
String message = "Hello, " + name;
```
This process is called concatenation.

The + operator concatenates two strings, provided one of the expressions, either to the left or the right of a + operator, is a string. The other one is automatically forced to become a string as well, and both strings are concatenated. For example, consider this code:
```
String a = "Agent";
int n = 7;
String bond = a + n;
```
Because a is a string, n is converted from the integer 7 to the string "7". Then the two strings "Agent" and "7" are concatenated to form the string "Agent7". This concatenation is very useful to reduce the number of System.out.print instructions. For example, you can combine
```
System.out.print("The total is ");
System.out.println(total);
```
to the single call
```
System.out.println("The total is " + total);
```
The concatenation "The total is " + total computes a single string that consists of the string "The total is ", followed by the string equivalent of the number total.

Sometimes you have a string that contains a number, usually from user input. For example, suppose that the string variable input has the value "19". To get the integer value 19, you use the static parseInt method of the Integer class.
```
int count = Integer.parseInt(input);
// count is the integer 19
```
To convert a string containing ﬂoating-point digits to its ﬂoating-point value, use the static parseDouble method of the Double class. For example, suppose input is the string "3.95".
```
double price = Double.parseDouble(input);
// price is the ﬂoating-point number 3.95
```
However, if the string contains spaces or other characters that cannot occur inside numbers, an error occurs. For now, we will always assume that user input does not contain invalid characters.

The substring method computes substrings of a string. The call
```
s.substring(start, pastEnd);
```
returns a string that is made up of the characters in the string s, starting at position start, and containing all characters up to, but not including, the position pastEnd.

Here is an example:
```
String greeting = "Hello, World!";
String sub = greeting.substring(0, 5); // sub is "Hello"
```
The substring operation makes a string that consists of ﬁve characters taken from the string greeting. A curious aspect of the substring operation is the numbering of the starting and ending positions. The ﬁrst string position is labeled 0, the second one 1, and so on. For example, Figure 3 shows the position numbers in the greeting string.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/21.png</image>
				<text>
The position number of the last character (12 for the string "Hello, World!") is always 1 less than the length of the string.

Let us ﬁgure out how to extract the substring "World". Count characters starting at 0, not 1. You ﬁnd that W, the eighth character, has position number 7. The ﬁrst character that you don’t want, !, is the character at position 12 (see Figure 4).
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/23.png</image>
				<text>
Therefore, the appropriate substring command is
```
String sub2 = greeting.substring(7, 12);
```
It is curious that you must specify the position of the ﬁrst character that you do want and then the ﬁrst character that you don’t want. There is one advantage to this setup. You can easily compute the length of the substring: It is pastEnd - start. For example, the string "World" has length 12 – 7 = 5.

If you omit the second parameter of the substring method, then all characters from the starting position to the end of the string are copied. For example,
```
String tail = greeting.substring(7); // Copies all characters from position 7 on
```
sets tail to the string "World!".

If you supply an illegal string position (a negative number, or a value that is larger than the length of the string), then your program terminates with an error mess2853
age.
				</text>
			</page>
			<page title = "Self Check">
				<text>
1. Assuming the ```String``` variable s holds the value "Agent", what is the effect of the assignment
```
s = s + s.length()?
```
2. Assuming the ```String``` variable river holds the value "Mississippi", what is the value of ```river.substring(1, 2)```? Of ```river.substring(2, river.length() - 3)```?
				</text>
			</page>
			<page title = "Operators">
				<text>
Suppose you want to find whether amount is between 0 and 1000. Then two conditions have to be true: amount must be greater than 0, and it must be less than 1000. In Java you use the &amp;&amp; operator to represent the and when combining test conditions. That is, you can write the test as follows:
###
if (0 &lt; amount &amp;&amp; amount &lt; 1000) . . .
###
The &amp;&amp; (and) operator combines several tests into a new test that passes only when all conditions are true. An operator that combines Boolean values is called a Boolean operator. The &amp;&amp; operator has a lower precedence than the relational operators. For that reason, you can write relational expressions on either side of the &amp;&amp; operator without using parentheses. For example, in the expression
###
0 &lt; amount &amp;&amp; amount &lt; 1000
###
the expressions 0 &lt; amount and amount &lt; 1000 are evaluated first. Then the &amp;&amp; operator combines the results. Appendix B shows a table of the Java operators and their precedence.

The || (or) logical operator also combines two or more conditions. The resulting test succeeds if at least one of the conditions is true. For example, here is a test to check whether the string input is an "S" or "M":
###
if (input.equals("S") || input.equals("M")) . . .
###
Figure 6 shows flowcharts for these examples.

Sometimes you need to invert a condition with the ! (not) logical operator. For example, we may want to carry out a certain action only if two strings are not equal:
###
if (!input.equals("S")) . . .
###
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/27.png</image>
				<text>
The ! operator takes a single condition and evaluates to true if that condition is false and to false if the condition is true.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/29.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Operators/30.png</image>
				<text>
You can use a Boolean variable if you know that there are only two possible values. Have another look at the tax program in Section 5.3.2. The marital status is either single or married. Instead of using an integer, you can use a variable of type boolean:
```
private boolean married;
```
The advantage is that you can’t accidentally store a third value in the variable. Then you can use the Boolean variable in a test:
```
if (married)
	. . .
else
	. . .
```
Sometimes Boolean variables are called flags because they can have only two states:
“up” and “down”.

It pays to think carefully about the naming of Boolean variables. In our example, it would not be a good idea to give the name maritalStatus to the Boolean variable. What does it mean that the marital status is true? With a name like married there is
no ambiguity; if married is true, the taxpayer is married. By the way, it is considered gauche to write a test such as
```
if (married == true) . . . // Don’t
```
Just use the simpler test
```
if (married) . . .
```
				</text>
			</page>
			<page title = "Self Check">
				<text>
1. When does the statement print false?
```
System.out.println(x &gt; 0 || x &lt; 0);
```
2. Rewrite the following expression, avoiding the comparison with false:
```
if (Character.isDigit(ch) == false) . . .
```
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/3-object.png</image>
		<title>Object and Object Comparison</title>
		<description>Because Java is an Object-Oriented Language, it is important understand how to use classes, methods, and their components. In addition to these components, this chapter will go over the proper way of comparing two different objects</description>
		<pages>
			<page title = "What is an Object?">
				<text>
An object is a value that you can manipulate by calling one or more of its methods. A method consists of a sequence of instructions that can access the internal data of an object. When you call the method, you do not know exactly what those instructions are, or even how the object is organized internally. However, the behavior of the method is well-defined, and that is what matters to us when we use
it.

For example, System.out refers to an object. You manipulate it by calling the println method. When the println method is called, some activities occur inside the object, and the ultimate effect is that text appears in the console window. You don’t know how that happens, and that’s OK. What matters is that the method carries out the work that you requested. Figure 4 shows a representation of the System.out object. The internal data is symbolized by a sequence of zeroes and ones. Think of each method (symbolized by the gears) as a piece of machinery that carries out its assigned task. You encountered two objects:
###
• System.out
• "Hello, World!"
###
The type of an object is a class. The System.out object belongs to the class PrintStream. The "Hello, World!" object belongs to the class String. A class specifies the methods that you can apply to its objects.

You can use the println method with any object that belongs to the PrintStream class. System.out is one such object. It is possible to obtain other objects of the PrintStream class. For example, you can construct a PrintStream object to send output to a file. However, we won’t discuss files until later.

Just as the PrintStream class provides methods such as println and print for its objects, the String class provides methods that you can apply to String objects. One of them is the length method. The length method counts the number of characters in a string.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/2.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/3.png</image>
				<text>
You can apply that method to any object of type String.

For example, the sequence of statements
```
String greeting = "Hello, World!";
int n = greeting.length();
```
sets n to the number of characters in the String object "Hello, World!". After the instructions in the length method are executed, n is set to 13. (The quotation marks are not part of the string, and the length method does not count them.) The length method—unlike the println method—requires no input inside the parentheses. However, the length method yields an output, namely the character count.

In the next section, you will see in greater detail how to supply method inputs and obtain method outputs.

Let us look at another method of the String class. When you apply the toUpperCase method to a String object, the method creates another String object that contains the characters of the original string, with lowercase letters converted to uppercase. For example, the sequence of statements
```
String river = "Mississippi";
String bigRiver = river.toUpperCase();
```
sets bigRiver to the String object "MISSISSIPPI".

When you apply a method to an object, you must make sure that the method is declared in the appropriate class. For example, it is an error to call
```
System.out.length(); // This method call is an error
```
The PrintStream class (to which System.out belongs) has no length method. Let us summarize. In Java, every object belongs to a class. The class declares the methods for the objects. For example, the String class declares the length and toUpperCase methods (as well as other methods—you will learn about most of them in another chapter). The methods form the public interface of the class, telling you what you can do with the objects of the class. A class also declares a private implementation, describing the data inside its objects and the instructions for its methods. Those details are hidden from the programmers who use objects and call methods. Figure 5 shows two objects of the String class. Each object stores its own data (drawn as boxes that contain characters). Both objects support the same set of methods—the interface that is specified by the String class.

Occasionally, a class declares two methods with the same name and different parameter types. For example, the PrintStream class declares a second method, also called println, as
```
public void println(int output)
```
That method is used to print an integer value. We say that the println name is overloaded because it refers to more than one method.
				</text>
			</page>
			<page title = "Self Check">
				<text>
1. How can you compute the length of the string "Mississippi"?

2. How can you print out the uppercase version of "Hello, World!"?

3. Is it legal to call river.println()? Why or why not?
				</text>
			</page>
			<page title = "Constructing Objects">
				<text>
Most Java programs need to work on a variety of objects. In this section, you will see how to construct new objects. This allows you to go beyond String objects and the System.out object.

To learn about object construction, let us turn to another class: the Rectangle class in the Java class library. Objects of type Rectangle describe rectangular shapes—see Figure 10. These objects are useful for a variety of purposes. You can assemble rectangles into bar charts, and you can program simple games by moving rectangles inside a window.

Note that a Rectangle object isn’t a rectangular shape—it’s an object that contains a set of numbers. The numbers describe the rectangle (see Figure 11). Each rectangle is described by the x- and y-coordinates of its top-left corner, its width, and its height. It is very important that you understand this distinction. In the computer, a Rectangle object is a block of memory that holds four numbers, for example x = 5, y = 10, width = 20, height = 30. In the imagination of the programmer who uses a Rectangle object, the object describes a geometric figure.

To make a new rectangle, you need to specify the x, y, width, and height values. Then invoke the new operator, specifying the name of the class and the parameters that are required for constructing a new object. For example, you can make a new rectangle with its top-left corner at (5, 10), width 20, and height 30 as follows:
```
new Rectangle(5, 10, 20, 30)
```
Here is what happens in detail:

1. The new operator makes a Rectangle object.
2. It uses the parameters (in this case, 5, 10, 20, and 30) to initialize the data of the object.
3. It returns the object.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/6.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/7.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/8.png</image>
				<text>
The process of creating a new object is called construction. The four values 5, 10, 20, and 30 are called the construction parameters.

The new expression yields an object, and you need to store the object if you want to use it later. Usually you assign the output of the new operator to a variable. For example,
```
Rectangle box = new Rectangle(5, 10, 20, 30);
```
Some classes let you construct objects in multiple ways. For example, you can also obtain a Rectangle object by supplying no construction parameters at all (but you must still supply the parentheses):
```
new Rectangle()
```
This expression constructs a (rather useless) rectangle with its top-left corner at the origin (0, 0), width 0, and height 0.
				</text>
			</page>
			<page title = "Self Check">
				<text>
1. How do you construct a square with center (100, 100) and side length 20?

2. The getWidth method returns the width of a Rectangle object. What does the following statement print?
```
System.out.println(new Rectangle().getWidth());
```
				</text>
			</page>
			<page title = "Methods">
				<text>
In this section we introduce a useful terminology for the methods of a class. A method that accesses an object and returns some information about it, without changing the object, is called an accessor method. In contrast, a method whose purpose is to modify the internal data of an object is called a mutator method. For example, the length method of the String class is an accessor method. It
returns information about a string, namely its length. But it doesn’t modify the string at all when counting the characters.

The Rectangle class has a number of accessor methods. The getX, getY, getWidth, and getHeight methods return the x- and y-coordinates of the top-left corner, the width, and the height values. For example,
```
double width = box.getWidth();
```
Now let us consider a mutator method. Programs that manipulate rectangles frequently need to move them around, for example, to display animations. The Rectangle class has a method for that purpose, called translate. (Mathematicians use the term “translation” for a rigid motion of the plane.)
```
box.translate(15, 25);
```
This method moves a rectangle by a certain distance in the x- and y-directions. The method call, moves the rectangle by 15 units in the x-direction and 25 units in the y-direction (see Figure 12). Moving a rectangle doesn’t change its width or height, but it changes the top-left corner. Afterward, the rectangle that had its top-left corner at (5, 10) now has it at (20, 35).

This method is a mutator because it modifies the implicit parameter object.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/11.png</image>
			</page>
			<page title = "Self Check">
				<text>
1. Is the toUpperCase method of the String class an accessor or a mutator?

2. Which call to translate is needed to move the rectangle declared by Rectangle box = new Rectangle(5, 10, 20, 30) so that its top-left corner is the origin (0, 0)?
				</text>
			</page>
			<page title = "Object Memory">
				<text>
In Java, a variable whose type is a class does not actually hold an object. It merely holds the memory location of an object. The object itself is stored elsewhere—see Figure 17. There is a reason for this behavior. Objects can be very large. It is more efficient to store only the memory location instead of the entire object.

We use the technical term object reference to denote the memory location of an object. When a variable contains the memory location of an object, we say that it refers to an object. For example, after the statement
```
Rectangle box = new Rectangle(5, 10, 20, 30);
```
the variable box refers to the Rectangle object that the new operator constructed. Technically speaking, the new operator returned a reference to the new object, and that reference is stored in the box variable.

It is very important that you remember that the box variable does not contain the object. It refers to the object. Two object variables can refer to the same object:
```
Rectangle box2 = box;
```
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/14.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/15.png</image>
				<text>
Now you can access the same Rectangle object both as box and as box2, as shown in Figure 18. However, number variables actually store numbers. When you declare
```
int luckyNumber = 13;
```
then the luckyNumber variable holds the number 13, not a reference to the number (see Figure 19). The reason is again efficiency. Because numbers require little storage, it is more efficient to store them directly in a variable.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/17.png</image>
				<text>
You can see the difference between number variables and object variables when you make a copy of a variable. When you copy a number, the original and the copy of the number are independent values. But when you copy an object reference, both the original and the copy are references to the same object.

Consider the following code, which copies a number and then changes the copy (see Figure 20):
```
int luckyNumber = 13; 
int luckyNumber2 = luckyNumber;
luckyNumber2 = 12; 
```
Now the variable luckyNumber contains the value 13, and luckyNumber2 contains 12.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/19.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/20.png</image>
				<text>
Now consider the seemingly analogous code with Rectangle objects (see Figure 21).
```
Rectangle box = new Rectangle(5, 10, 20, 30);
Rectangle box2 = box;
box2.translate(15, 25);
```
Since box and box2 refer to the same rectangle after step 2 , both variables refer to the moved rectangle after the call to the translate method.

You need not worry too much about the difference between objects and object references. Much of the time, you will have the correct intuition when you think of “the object box” rather than the technically more accurate “the object reference stored in box”. The difference between objects and object references only becomes apparent when you have multiple variables that refer to the same object.
				</text>
			</page>
			<page title = "Self Check">
				<text>
1. What is the effect of the assignment: String greeting2 = greeting?

2. After calling greeting2.toUpperCase(), what are the contents of greeting and greeting2?
				</text>
			</page>
			<page title = "Relational Operators">
				<text>
A relational operator tests the relationship between two values. An example is the &lt;= operator that we used in the test
```
if (amount &lt;= balance)
```
Java has six relational operators:
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/23.png</image>
				<text>
As you can see, only two relational operators (&gt; and &lt;) look as you would expect from the mathematical notation. Computer keyboards do not have keys for ≥, ≤, or ≠, but the &gt;=, &lt;=, and != operators are easy to remember because they look similar. The == operator is initially confusing to most newcomers to Java. In Java, the = symbol already has a meaning, namely assignment. The == operator denotes equality testing:
```
a = 5; // Assign 5 to a
if (a == 5) . . . // Test whether a equals 5
```
You will have to remember to use == for equality testing, and to use = for assignment.

The relational operators have a lower precedence than the arithmetic operators. That means, you can write arithmetic expressions on either side of the relational operator without using parentheses. For example, in the expression
```
amount + fee &lt;= balance
```
both sides (amount + fee and balance) of the &lt; operator are evaluated, and the results are compared. Appendix B shows a table of the Java operators and their precedence.

You have to be careful when comparing floating-point numbers, in order to cope with roundoff errors. For example, the following code multiplies the square root of 2 by itself and then subtracts 2.
```
double r = Math.sqrt(2);
double d = r * r - 2;
if (d == 0)
  System.out.println("sqrt(2) squared minus 2 is 0");
else
  System.out.println("sqrt(2) squared minus 2 is not 0 but " + d);
```
Even though the laws of mathematics tell us that fragment prints
###sqrt(2) squared minus 2 is 0###
this program actually prints
###sqrt(2) squared minus 2 is not 0 but 4.440892098500626E-16###

Unfortunately, such roundoff errors are unavoidable. It plainly does not make sense in most circumstances to compare floating-point numbers exactly. Instead, test whether they are close enough.

To test whether a number x is close to zero, you can test whether the absolute value | x| (that is, the number with its sign removed) is less than a very small threshold number. That threshold value is often called ε (the Greek letter epsilon). It is common to set ε to 10–14 when testing double numbers. Similarly, you can test whether two numbers are approximately equal by checking whether their difference is close to 0.
###
|x−y| ≤ε
###
In Java, we program the test as follows:
```
final double EPSILON = 1E-14;
if (Math.abs(x - y) &lt;= EPSILON)
	// x is approximately equal to y
```
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/25.png</image>
			</page>
			<page title = "String Equality">
				<text>
To test whether two strings are equal to each other, you must use the method called
equals:
```
if (string1.equals(string2)) . . .
```
Do not use the == operator to compare strings. The expression
```
if (string1 == string2) // Not useful
```
has an unrelated meaning. It tests whether the two string variables refer to the identical string object. You can have strings with identical contents stored in different objects, so this test never makes sense in actual programming.

In Java, letter case matters. For example, "Harry" and "HARRY" are not the same string. To ignore the letter case, use the equalsIgnoreCase method:
```
if (string1.equalsIgnoreCase(string2)) . . .
```
If two strings are not identical to each other, you still may want to know the relationship between them. The compareTo method compares strings in dictionary order. If
```
string1.compareTo(string2) &lt; 0
```
then the string string1 comes before the string string2 in the dictionary. For example, this is the case if string1 is "Harry", and string2 is "Hello". If
```
string1.compareTo(string2) &gt; 0
```
then string1 comes after string2 in dictionary order. Finally, if
```
string1.compareTo(string2) == 0
```
then string1 and string2 are equal.

Actually, the “dictionary” ordering used by Java is slightly different from that of a normal dictionary. Java is case sensitive and sorts characters by putting numbers first, then uppercase characters, then lowercase characters. For example, 1 comes before B, which comes before a. The space character comes before all other characters.

Let us investigate the comparison process closely. When Java compares two strings, corresponding letters are compared until one of the strings ends or the first difference is encountered. If one of the strings ends, the longer string is considered the later one. If a character mismatch is found, the characters are compared to determine which string comes later in the dictionary sequence. This process is called lexicographic comparison. For example, let’s compare "car" with "cargo". The first three letters match, and we reach the end of the first string. Therefore "car" comes before "cargo" in the lexicographic ordering. Now compare "cathode" with "cargo". The first two letters match. In the third character position, t comes after r, so the string "cathode" comes after "cargo" in lexicographic ordering. (See Figure 3.)
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/27.png</image>
			</page>
			<page title = "Relational Operator Tbl.">
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/28.png</image>
			</page>
			<page title = "Common Relational Errors">
				<text>
Common Error 5.2: Using == to Compare Strings

It is an extremely common error in Java to write == when equals is intended. This is particularly true for strings. If you write
```
if (nickname == "Rob")
```
then the test succeeds only if the variable nickname refers to the exact same string object as the string constant "Rob". For efficiency,Java makes only one string object for every string constant. Therefore, the following test will pass:
```
String nickname = "Rob";
. . .
if (nickname == "Rob") //Test is true
```
However, if the string with the letters R o b has been assembled in some other way, then the test will fail:
```
String name = "Robert";
String nickname = name.substring(0, 3);
. . .
if (nickname == "Rob") // Test is false
```
This is a particularly distressing situation: The wrong code will sometimes do the right thing, sometimes the wrong thing. Because string objects are always constructed by the compiler, you never have an interest in whether two string objects are shared. You must remember never to use == to compare strings. Always use equals or compareTo to compare strings.

5.2.4 Comparing Objects

If you compare two object references with the == operator, you test whether the references refer to the same object. Here is an example:
```
Rectangle box1 = new Rectangle(5, 10, 20, 30);
Rectangle box2 = box1;
Rectangle box3 = new Rectangle(5, 10, 20, 30);
```
The comparison
```
box1 == box2
```
is true. Both object variables refer to the same object. But the comparison
```
box1 == box3
```
is false. The two object variables refer to different objects (see Figure 4). It does not matter that the objects have identical contents. You can use the equals method to test whether two rectangles have the same contents, that is, whether they have the same upper-left corner and the same width and height. For example, the test
```
box1.equals(box3)
```
is true.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Object%20and%20Object%20Comparison/30.png</image>
				<text>
However, you must be careful when using the equals method. It works correctly only if the implementors of the class have supplied it. The Rectangle class has an equals method that is suitable for comparing rectangles.

For your own classes, you need to supply an appropriate equals method. You will learn how to do that later on. Until that point, you should not use the equals method to compare objects of your own classes.

5.2.5:  Testing for null

An object reference can have the special value null if it refers to no object at all. It is common to use the null value to indicate that a value has never been set. For example,
``` 
String middleInitial = null; // Not set
if ( . . . )
middleInitial = middleName.substring(0, 1);
```
You use the == operator (and not equals) to test whether an object reference is a null reference:
```
if (middleInitial == null)
   System.out.println(firstName + " " + lastName);
else
   System.out.println(firstName + " " + middleInitial + ". " + lastName);
```
Note that the null reference is not the same as the empty string "". The empty string is a valid string of length 0, whereas a null indicates that a string variable refers to no string at all.
				</text>
			</page>
			<page title = "Self Check">
				<text>
1. What is the value of s.length() if s is
	a. the empty string ""?
	b. the string " " containing a space?
	c. null?

2. Which of the following comparisons are syntactically incorrect? Which of them
are syntactically correct, but logically questionable?
```
String a = "1";
String b = "one";
double x = 1;
double y = 3 * (1.0 / 3);
```
	a. a == "1"
	b. a == null
	c. a.equals("")
	d. a == b
	e. a == x
	f. x == y
	g. x - y == null
	h. x.equals(y)
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/variables.png</image>
		<title>Variables</title>
		<description>Explore parameter, local, instance, and class variables</description>
		<pages>
			<page>
				<text>
You often want to store values so that you can use them at a later time. To remember a value, you need to hold it in a variable. A variable is a storage location in the computer’s memory that has a type, name, and contents. For example, here we declare three variables:
```
String greeting = "Hello, World!";
PrintStream printer = System.out;
int width = 20;
```
The first variable is called greeting. It can be used to store String values, and it is set to the value ###"Hello, World!"###. The second variable, printer, stores a PrintStream value, and the third stores an integer. Variables can be used in place of the values that they store:
```
printer.println(greeting); // Same as System.out.println("Hello, World!")
printer.println(width); // Same as System.out.println(20)
```
When you declare your own variables, you need to make two decisions.
• What type should you use for the variable?
• What name should you give the variable?

The type depends on the intended use. If you need to store a string, use the String type for your variable. If you need a number, choose the int or double type. It is an error to store a value whose type does not match the type of the variable.

For example, the following is an error:
```
String greeting = 20; // ERROR: Types don’t match
```
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/2.png</image>
				<text>
You cannot use a String variable to store an integer. The compiler checks type mismatches to protect you from errors.

When deciding on a name for a variable, you should make a choice that describes the purpose of the variable. For example, the variable name greeting is a better choice than the name g.

An identifier is the name of a variable, method, or class. Java imposes the following rules for identifiers:

• Identifiers can be made up of letters, digits, and the underscore (_) and dollar sign
  ($) characters. They cannot start with a digit, though.
• You cannot use spaces or symbols such as ? or %.
• Furthermore, you cannot use reserved words, such as public, as names; these words are reserved exclusively for their special Java meanings.

These are firm rules of the Java language. If you violate one of them, the compiler will report an error. Moreover, there are a couple of conventions that you should follow so that other programmers will find your programs easy to read:

• Variable and method names should start with a lowercase letter. It is OK to use an occasional uppercase letter, such as farewellMessage. This mixture of lowercase  and uppercase letters is sometimes called “camel case” because the uppercase letters stick out like the humps of a camel.
• Class names should start with an uppercase letter. For example, Greeting would be an appropriate name for a class, but not for a variable.
• You should not use the $ symbol in names. It is intended for names that are automatically generated by tools.

If you violate these conventions, the compiler won’t complain, but you will confuse other programmers who read your code.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/4.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/5.png</image>
				<text>
Table 3 shows examples of legal and illegal variable names in Java.
				</text>
			</page>
			<page title = "Self Check">
				<text>
1. Which of the following are legal identifiers?
```
Greeting1
g
void
101dalmatians
#Hello, World
```
2. Declare a variable to hold your name. Use camel case in the variable name.
				</text>
			</page>
			<page title="Tips: Variable Names">
				<text>
--Choose Descriptive Names for Variables--

In algebra, variable names are usually just one letter long, such as p or A, maybe with a subscript such as p1. You might be tempted to save yourself a lot of typing by using short variable names in your Java programs:
```
int A = w * h;
```
Compare this with the following statement:
```
int area = width * height;
```
The advantage is obvious. Reading width is much easier than reading w and then figuring out that it must mean “width”.

In practical programming, descriptive variable names are particularly important when programs are written by more than one person. It may be obvious to you that w stands for width, but is it obvious to the person who needs to update your code years later? For that
matter, will you yourself remember what w means when you look at the code a month from now?
				</text>
			</page>
			<page title="Objects">
				<text>
You learned how to use objects from existing classes. In this chapter, you will start implementing your own classes. We begin with a very simple example that shows you how objects store their data, and how methods access the data of an object. You will then learn a systematic process for implementing classes.

Our first example is a class that models a tally counter, a mechanical device that is used to count people—for example, to find out how many people attend a concert or board a bus (see Figure 1).

Whenever the operator pushes a button, the counter value advances by one. We model this operation with a count method. A physical counter has a display to show the current value. In our simulation, we use a getValue method instead. For example,
```
Counter tally = new Counter();
tally.count();
tally.count();
int result = tally.getValue(); // Sets result to 2
```
When implementing the Counter class, we need to determine the data that each counter object contains. In this simple example, that is very straightforward. Each counter needs to store a variable that keeps track of how many times the counter has been advanced.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/8.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/9.png</image>
				<text>
An object stores its data in instance variables. An instance of a class is an object of the class. Thus, an instance variable is a storage location that is present in each object of the class. You specify instance variables in the class declaration:
```
public class Counter
{
	private int value;
	. . .
}
```
An instance variable declaration consists of the following parts:
• An access specifier (private)
• The type of the instance variable (such as int)
• The name of the instance variable (such as value)

Each object of a class has its own set of instance variables. For example, if concertand boardingCounter are two objects of the Counter class, then each object has its own value variable (see Figure 2). As you will see in the future, the instance variable value is set to 0 when a Counter object is constructed. In order to gain a better understanding of how methods affect instance variables, we will have a quick look at the implementation of the methods of the Counter class.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/11.png</image>
				<text>
The count method advances the counter value by 1. We will cover the syntax of the method header in another section. For now, focus on the body of the method inside the braces:
```
public void count()
{
	value = value + 1;
}
```
Note how the count method accesses the instance variable value. Which instance variable? The one belonging to the object on which the method is invoked. For example, consider the call
```
concertCounter.count();
```
This call advances the value variable of the concertCounter object. The getValue method returns the current value:
```
public int getValue()
{
	return value;
}
```
The return statement is a special statement that terminates the method call and returns a result to the method’s caller.

Instance variables are generally declared with the access specifier private. That specifier means that they can be accessed only by the methods of the same class, not by any other method. For example, the value variable can be accessed by the count and getValue methods of the Counter class but not a method of another class. Those other methods need to use the Counter class methods if they want to manipulate a counter’s value.

In the next section, we discuss the reason for making instance variables private.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. Supply the body of a method public void reset() that resets the counter back to zero.

2. Suppose you use a class Clock with private instance variables hours and minutes. How can you access these variables in your program?
				</text>
			</page>
			<page title="Local/Parameter Variables">
				<text>
In this section, we discuss the behavior of local variables. A local variable is a variable that is declared in the body of a method. For example, the giveChange method in declares a local variable change:
```
public double giveChange()
{
	double change = payment - purchase;
	purchase = 0;
	payment = 0;
	return change;
}
```
Parameter variables are similar to local variables, but they are declared in method headers. For example, the following method declares a parameter variable amount:
```
public void enterPayment(double amount)
```
Local and parameter variables belong to methods. When a method runs, its local and parameter variables come to life. When the method exits, they are removed immediately. For example, if you call register.giveChange(), then a variable change is created. When the method exits, that variable is removed. In contrast, instance variables belong to objects, not methods. When an object is constructed, its instance variables are created. The instance variables stay alive until no method uses the object any longer. (The Java virtual machine contains an agent called a garbage collector that periodically reclaims objects when they are no longer used.)

An important difference between instance variables and local variables is initialization. You must initialize all local variables. If you don’t initialize a local variable, the compiler complains when you try to use it. (Note that parameter variables are initialized when the method is called.)

Instance variables are initialized with a default value before a constructor is invoked. Instance variables that are numbers are initialized to 0. Object references are set to a special value called null. If an object reference is null, then it refers to no object at all. We will discuss the null value in greater detail later.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. What do local variables and parameter variables have in common? In which essential aspect do they differ?

2. Why was it necessary to introduce the local variable change in the giveChange method? That is, why didn’t the method simply end with the statement:
```
return payment - purchase;
```
				</text>
			</page>
			<page title="Implicit Parameters">
				<text>
In a previous section, you learned that a method has an implicit parameter (the object on which the method is invoked) in addition to the explicit parameters, which are enclosed in parentheses. In this section, we will examine implicit parameters in greater detail.

Have a look at a particular invocation of the deposit method:
```
momsSavings.deposit(500);
```
Here, the implicit parameter is momsSavings and the explicit parameter is 500. Now look again at the code of the deposit method:
```
public void deposit(double amount)
{
	balance = balance + amount;
}
```
What does balance mean exactly? After all, our program may have multiple Bank-Account objects, and each of them has its own balance.
Of course, since we are depositing the money into momsSavings, balance must mean momsSavings.balance. In general, when you refer to an instance variable inside a method, it means the instance variable of the implicit parameter.

If you need to, you can access the implicit parameter—the object on which the method is called—with the reserved word this. For example, in the preceding method invocation, this refers to the same object as momsSavings (see Figure 6). The statement
```
balance = balance + amount;
```
actually means
```
this.balance = this.balance + amount;
```
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/14.png</image>
			</page>
			<page title="Instance Variables">
				<text>
When you refer to an instance variable in a method, the compiler automatically applies it to the this reference. Some programmers actually prefer to manually insert the this reference before every instance variable because they find it makes the code clearer. Here is an example:
```
public BankAccount(double initialBalance)
{
	this.balance = initialBalance;
}
```
You may want to try it out and see if you like that style. The this reference can also be used to distinguish between instance variables and local or parameter variables. Consider the constructor
```
public BankAccount(double balance)
{
	this.balance = balance;
}
```
The expression this.balance clearly refers to the balance instance variable. However, the expression balance by itself seems ambiguous. It could denote either the parameter variable or the instance variable. In Java, local and parameter variables are considered first when looking up variable names. Therefore,
```
this.balance = balance;
```
means: “Set the instance variable balance to the parameter variable balance”. There is another situation in which it is important to understand the implicit parameter. Consider the following modification to the BankAccount class. We add a method to apply the monthly account fee:
```
public class BankAccount
{
	. . .
	public void monthlyFee()
	{
		withdraw(10); // Withdraw $10 from this account
	}
}
```
That means to withdraw from the same bank account object that is carrying out the monthlyFee operation. In other words, the implicit parameter of the withdraw method is the (invisible) implicit parameter of the monthlyFee method. If you find it confusing to have an invisible parameter, you can use the this reference to make the method easier to read:
```
public class BankAccount
{
	. . .
	public void monthlyFee()
	{
		this.withdraw(10); // Withdraw $10 from this account
	}
}
```
You have now seen how to use objects and implement classes, and you have learned some important technical details about variables and method parameters. The remainder of this chapter continues the optional graphics track. In a different section, you will learn more about the most fundamental data types of the Java language.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. How many implicit and explicit parameters does the withdraw method of the BankAccount class have, and what are their names and types?

2. In the deposit method, what is the meaning of this.amount? Or, if the expression has no meaning, why not?

3. How many implicit and explicit parameters does the main method of the BankAccountTester class have, and what are they called?

				</text>
			</page>
			<page title="Static Variables">
				<text>
Sometimes, a value properly belongs to a class, not to any object of the class. You use a static variable for this purpose. Here is a typical example. We want to assign bank account numbers sequentially. That is, we want the bank account constructor to construct the first account with number 1001, the next with number 1002, and so on. Therefore, we must store the last assigned account number somewhere.

Of course, it makes no sense to make this value into an instance variable:
```
public class BankAccount
{
	private double balance;
	private int accountNumber;
	private int lastAssignedNumber = 1000; // NO—won’t work
	. . .
}
```
In that case each instance of the BankAccount class would have its own value of lastAssignedNumber.

Instead, we need to have a single value of lastAssignedNumber that is the same for the entire class. Such a variable is called a static variable, because you declare it using the static reserved word.
```
public class BankAccount
{
	private double balance;
	private int accountNumber;
	private static int lastAssignedNumber = 1000;
	. . .
}
```
Every BankAccount object has its own balance and accountNumber instance variables, but there is only a single copy of the lastAssignedNumber variable (see Figure 4). That variable is stored in a separate location, outside any BankAccount objects.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/17.png</image>
				<text>
A static variable is sometimes called a class variable because there is a single variable for the entire class. Every method of a class can access its static variables. Here is the constructor of the BankAccount class, which increments the last assigned number and then uses it to initialize the account number of the object to be constructed:
```
public class BankAccount
{
	. . .
	public BankAccount()
	{
		lastAssignedNumber++; // Updates the static variable
		accountNumber = lastAssignedNumber; // Sets the instance variable
	}
}
```
There are three ways to initialize a static variable:

1. Do nothing. The static variable is then initialized with 0 (for numbers), false (for boolean values), or null (for objects).

2. Use an explicit initializer, such as 
```
public class BankAccount
{
	private static int lastAssignedNumber = 1000;
	. . .
}
```
3. Use a static initialization block.

Like instance variables, static variables should always be declared as private to ensure that methods of other classes do not change their values. The exception to this rule are static constants, which may be either private or public. For example, the BankAccount class may want to declare a public constant value, such as
```
public class BankAccount
{
	public static final double OVERDRAFT_FEE = 29.95;
	. . .
}
```
Methods from any class can refer to such a constant as BankAccount.OVERDRAFT_FEE. It makes sense to declare constants as static—you wouldn’t want every object of the BankAccount class to have its own set of variables with these constant values. It is sufficient to have one set of them for the class.

Why are class variables called static? As with static methods, the static reserved word itself is just a meaningless holdover from C++. But static variables and static methods have much in common: They apply to the entire class, not to specific instances of the class.

In general, you want to minimize the use of static methods and variables. If you find yourself using lots of static methods that access static variables, then that’s an indication that you have not found the right classes to solve your problem in an object-oriented way.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. Name two static variables of the System class.

2. Harry tells you that he has found a great way to avoid those pesky objects: Put all code into a single class and declare all methods and variables static. Then main can call the other static methods, and all of them can access the static variables. Will Harry’s plan work? Is it a good idea?
				</text>
			</page>
			<page title="Scope">
				<text>
The scope of a variable is the part of the program in which the variable can be accessed. It is considered good design to minimize the scope of a variable. This reduces the possibility of accidental modification and name conflicts. In the following sections, you will learn how to determine the scopes of local and instance variables, and how to resolve name conflicts if the scopes overlap.

The scope of a local variable extends from the point of its declaration to the end of the block or for loop that encloses it. The scope of a parameter variable is the entire method.
```
public static void process(double[] values) // values is a parameter variable
{
	for (int i = 0; i &lt; 10; i++) // i is a local variable declared in a for loop
	{
		if (values[i] == 0)
		{
			double r = Math.random(); // r i s a local variable declared in a block
			values[i] = r;
		} // Scope of r ends here
	} // Scope of i ends here
} // Scope of values ends here
```
In Java, the scope of a local variable can never contain the declaration of another local variable with the same name. For example, the following is an error:
```
public static void main(String[] args)
{
	double r = Math.random();
	if (r > 0.5)
	{
		Rectangle r = new Rectangle(5, 10, 20, 30);
		// Error—can’t declare another variable called r here
		. . .
	}
}
```
However, you can have local variables with identical names if their scopes do not overlap, such as
```
if (Math.random() > 0.5)
{
	Rectangle r = new Rectangle(5, 10, 20, 30);
	. . .
} // Scope of r ends here
else
{
	int r = 5;
	// OK—it is legal to declare another r here
	. . .
}
```
These variables are independent from each other, or, in other words, their scopes are disjoint. You can have local variables with the same name r in different methods, just as you can have different motels with the same name “Bates Motel” in different cities.

In contrast, the scope of instance variables and static variables consists of the entire class in which they are declared.

Problems arise if you have two identical variable names with overlapping scope. This can never occur with local variables, but the scopes of identically named local variables and instance variables can overlap. Here is a purposefully bad example.
```
public class Coin
{
	private String name;
	private double value; // Instance variable
	. . .

	public double getExchangeValue(double exchangeRate)
	{
		double value; // Local variable with the same name
		. . .
		return value;
	}
}
```
Inside the getExchangeValue method, the variable name value could potentially have two meanings: the local variable or the instance variable. The Java language specifies that in this situation the local variable wins out. It shadows the instance variable.

This sounds pretty arbitrary, but there is actually a good reason: You can still refer to the instance variable as this.value.
```
value = this.value * exchangeRate;
```
Of course, it is not a good idea to write code like this. You can easily change the name of the local variable to something else, such as result.

However, there is one situation where overlapping scope is acceptable. When implementing constructors or setter methods, it can be awkward to come up with different names for instance variables and parameters. Here is how you can use the same name for both:
```
public Coin(double value, String name)
{
	this.value = value;
	this.name = name;
}
```
The expression this.value refers to the instance variable, and value is the parameter.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. Consider the following program that uses two variables named r. Is this legal?
```
public class RectangleTester
{
	public static double area(Rectangle rect)
	{
		double r = rect.getWidth() * rect.getHeight();
		return r;
	}
	public static void main(String[] args)
	{
		Rectangle r = new Rectangle(5, 10, 20, 30);
		double a = area(r);
		System.out.println(r);
	}
}
```
2. What is the scope of the balance variable of the BankAccount class?
				</text>
			</page>
			<page title="Errors: Shadowing">
				<text>
Common Error: Shadowing

Accidentally using the same name for a local variable and an instance variable is a surprisingly common error. As you saw in the preceding section, the local variable then shadows the instance variable. Even though you may have meant to access the instance variable, the local variable is quietly accessed. Look at this example of an incorrect constructor:
```
public class Coin
{
	private double value;
	private String name;
	. . .

	public Coin(double aValue, String aName)
	{
		value = aValue;
		String name = aName; // Oops . . .
	}
}
```
The programmer declared a local variable name in the constructor. In all likelihood, that was just a typo—the programmer’s fingers were on autopilot and typed the reserved word String, even though the programmer all the time intended to access the instance variable. Unfortunately, the compiler gives no warning in this situation and quietly sets the local variable to the value of aName. The instance variable of the object that is being constructed is never touched, and remains null.

Some programmers give all instance variable names a special prefix to distinguish them from other variables. A common convention is to prefix all instance variable names with the prefix my, such as myValue or myName.

Another way of avoiding this problem is to use the this parameter when accessing an instance variable:
```
this.name = aName;
```
Quality Tip: Minimize Variable Scope

When you make the scope of a variable as small as possible, it becomes less likely that the variable is accidentally corrupted. It also becomes easier to modify or eliminate the variable as you reorganize your code.

As already mentioned, don’t make an instance variable public. (The Java library has a few classes with public instance variables, but their creators later regretted their decision when they were unable to make optimizations later.) When you have a constant, ask yourself who needs it. Everybody (public static final)? Only the class (private static final)? Only a single method (a final local variable)? Choose the smallest scope.

Beware of unnecessary instance variables. For example, you would not want an instance variable for the volume:
```
public class Pyramid
{
	private double height;
	private double baseLength;
	private double volume; // Not
	. . .
}```

a good idea to use class scope for this variable

Instead, compute the volume when it is needed in the getVolume method. That way, no other method can accidentally modify the volume variable, or forget to modify it when changing the height or base length.

Finally, with local variables, declare them only when you need them.
				</text>
			</page>
			<page title="Parameter Variables">
				<text>
Methods are fundamental building blocks of Java programs. A program performs useful work by calling methods. In this section, we will examine how to provide inputs into a method, and how to obtain the result of the method.

Most methods require inputs that give details about the work that the method needs to do. For example, the println method has an input: the string that should be printed. Computer scientists use the technical term parameter for method inputs. We say that the string greeting is a parameter of the method call
```
System.out.println(greeting);
```
Figure 6 illustrates passing of the parameter to the method. Technically speaking, the greeting parameter is an explicit parameter of the println method. The object on which you invoke the method is also considered a parameter of the method call; it is called the implicit parameter. For example, System.out is the implicit parameter of the method call
```
System.out.println(greeting);
```
Some methods require multiple explicit parameters, others don’t require any explicit parameters at all. An example of the latter is the length method of the String class (see Figure 7). All the information that the length method requires to do its job—namely, the character sequence of the string—is stored in the implicit parameter object.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/20.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/21.png</image>
				<text>
The length method differs from the println method in another way: it has an output. We say that the method returns a value, namely the number of characters in the string. You can store the return value in a variable:
```
int n = greeting.length();
```
You can also use the return value as a parameter of another method:
```
System.out.println(greeting.length());
```
The method call greeting.length() returns a value—the integer 13. The return value becomes a parameter of the println method. Figure 8 shows the process. Not all methods return values. One example is the println method. The println method interacts with the operating system, causing characters to appear in a window. But it does not return a value to the code that calls it.

Let us analyze a more complex method call. Here, we will call the replace method of the String class. The replace method carries out a search-and-replace operation, similar to that of a word processor. For example, the call
```
river.replace("issipp", "our")
```
constructs a new string that is obtained by replacing all occurrences of "issipp" in "Mississippi" with "our". (In this situation, there was only one replacement.) The method returns the String object "Missouri". You can save that string in a variable:
```
river = river.replace("issipp", "our");
```
Or you can pass it to another method:
```
System.out.println(river.replace("issipp", "our"));
```
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/23.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Variables/24.png</image>
				<text>

As Figure 9 shows, this method call has
• one implicit parameter: the string "Mississippi"
• two explicit parameters: the strings "issipp" and "our"
• a return value: the string "Missouri"
When a method is declared in a class, the declaration specifies the types of the explicit parameters and the return value. For example, the String class declares the length method as
```
public int length()
```
That is, there are no explicit parameters, and the return value has the type int. (For now, all the methods that we consider will be “public” methods.

The type of the implicit parameter is the class that declares the method—String in our case. It is not mentioned in the method declaration—hence the term “implicit”. The replace method is declared as
```
public String replace(String target, String replacement)
```
To call the replace method, you supply two explicit parameters, target and replacement, which both have type String. The returned value is another string. When a method returns no value, the return type is declared with the reserved word void. For example, the PrintStream class declares the println method as
```
public void println(String output)
```
				</text>
			</page>
			<page title="Self Check">
				<text>
1. What are the implicit parameters, explicit parameters, and return values in the method call river.length()?

2. What is the result of the call river.replace("p", "s")?

3. What is the result of the call greeting.replace("World", "Dave").length()?

4. How is the toUpperCase method declared in the String class?
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/escape-sequences.png</image>
		<title>Escape Sequences</title>
		<description>Learn how to properly employ escape sequences.</description>
		<pages>
			<page>
				<text>
Suppose you want to display a string containing quotation marks, such as
###
"Hello, "World"!
###
You can’t use System.out.println("Hello, "World"!");

As soon as the compiler reads "Hello, ", it thinks the string is ﬁnished, and then it gets all confused about World followed by two quotation marks. A human would probably realize that the second and third quotation marks were supposed to be part of the string, but a compiler has a one-track mind. If a simple analysis of the input doesn’t make sense to it, it just refuses to go on, and reports an error. Well, how do you then display quotation marks on the screen? You precede the quotation marks inside the string with a backslash character. Inside a string, the sequence \" denotes a literal quote, not the end of a string. The correct display statement is, therefore
```
System.out.println("Hello, \"World\"!");
```
The backslash character is used as an escape character; the character sequence \" is called an escape sequence. The backslash does not denote itself; instead, it is used to encode other characters that would otherwise be difﬁcult to include in a string.

Now, what do you do if you actually want to print a backslash (for example, to specify a Windows ﬁle name)? You must enter two \\ in a row, like this:
```
System.out.println("The secret message is in C:\\Temp\\Secret.txt");
```
This statement prints
###
The secret message is in C:\Temp\Secret.txt
###
Another escape sequence occasionally used is \n, which denotes a newline or line feed character. Printing a newline character causes the start of a new line on the display. For example, the statement
```
System.out.print("*\n**\n***\n");
```
prints the characters
###
*
**
***
###
on three separate lines. Of course, you could have achieved the same effect with three separate calls to println.

Finally, escape sequences are useful for including international characters in a string. For example, suppose you want to print ###“All the way to San José!”###, with an accented letter (é). If you use a U.S. keyboard, you may not have a key to generate that letter. Java uses the Unicode encoding scheme to denote international characters. For example, the é character has Unicode encoding 00E9. You can include that character inside a string by writing \u, followed by its Unicode encoding:
```
System.out.println("All the way to San Jos\u00E9!");
```
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/methods.png</image>
		<title>Methods</title>
		<description>Learn about public, private, and static methods. Also, consider overloading, parameter passing, and overriding.</description>
		<pages>
			<page >
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Methods/0.png</image>
				<text>
Imagine that you are a member of a team that works on banking software. A fundamental concept in banking is a bank account. Your task is to understand the design of a BankAccount class so that you can implement it, which in turn allows other programmers on the team to use it.

You need to know exactly what features of a bank account need to be implemented. Some features are essential (such as deposits), whereas others are not important (such as the gift that a customer may receive for opening a bank account). Deciding which features are essential is not always an easy task. We will revisit that issue in later chapters. For now, we will assume that a competent designer has
decided that the following are considered the essential operations of a bank account:

	• Deposit money
	• Withdraw money
	• Get the current balance

In Java, operations are expressed as method calls. To figure out the exact specification of the method calls, imagine how a programmer would carry out the bank account operations. We’ll assume that the variable harrysChecking contains a reference to an object of type BankAccount. We want to support method calls such as the following:
```
harrysChecking.deposit(2240.59);
harrysChecking.withdraw(500);
double currentBalance = harrysChecking.getBalance();
```
The first two methods are mutators. They modify the balance of the bank account and don’t return a value. The third method is an accessor. It returns a value that you store in a variable or pass to a method.

As you can see from the sample calls, the BankAccount class should declare three methods:
```
	• public void deposit(double amount)
	• public void withdraw(double amount)
	• public double getBalance()
```
Recall from before that double denotes the double-precision floating-point type, and void indicates that a method does not return a value. Here we only give the method headers. When you declare a method, you also need to provide the method body, consisting of statements that are executed when the method is called.
```
public void deposit(double amount)
{
	implementation—filled in later
}
```
We will supply the method bodies in a later section. Every method header contains the following parts:

	• An access specifier (usually public)
	• The return type (the type of the value returned, such as void or double)
	• The name of the method (such as deposit)
	• A list of the parameter variables of the method (if any), enclosed in parentheses
	(such as (double amount))

The access specifier controls which other methods can call this method. Most methods should be declared as public. That way, all other methods in a program can call them. (Occasionally, it can be useful to have private methods. They can only be called from other methods of the same class.)

The return type is the type of the value that the method returns. The deposit method does not return a value, whereas the getBalance method returns a value of type double.

Each parameter of the method has both a type and a name that describes its purpose. For example, the deposit method has a single parameter named amount of type double. Next, you need to supply constructors. A constructor initializes the instance variables of an object. In Java, a constructor is very similar to a method, with two important differences.

	• The name of the constructor is always the same as the name of the class (e.g., BankAccount).
	• Constructors have no return type (not even void).

We want to construct bank accounts that initially have a zero balance, as well as accounts that have a given initial balance. For this purpose, we specify two constructors.
```
	• public BankAccount()
	• public BankAccount(double initialBalance)
```
They are used as follows:
```
BankAccount harrysChecking = new BankAccount();
BankAccount momsSavings = new BankAccount(5000);
```
Just like a method, a constructor also has a body—a sequence of statements that is executed when a new object is constructed.
```
public BankAccount()
{
	implementation—filled in later
}
```
Don’t worry about the fact that there are two constructors with the same name—all constructors of a class have the same name, that is, the name of the class. The compiler can tell them apart because they take different parameters. When declaring a class, you place all constructor and method declarations inside, like this:
```
public class BankAccount
{
	private instance variables—filled in later
	// Constructors

	public BankAccount()
	{
		implementation—filled in later
	}

	public BankAccount(double initialBalance)
	{
		implementation—filled in later
	}

	// Methods

	public void deposit(double amount)
	{
		implementation—filled in later
	}

	public void withdraw(double amount)
	{
		implementation—filled in later
	}

	public double getBalance()
	{
		implementation—filled in later
	}
}
```
The public constructors and methods of a class form the public interface of the class. These are the operations that any programmer can use to create and manipulate BankAccount objects. Our BankAccount class is simple, but it allows programmers to carry out all of the important operations that commonly occur with bank accounts. For example, consider this program segment, authored by a programmer who uses the BankAccount class. These statements transfer an amount of money from one bank account to another:
```
// Transfer from one account to another
double transferAmount = 500;
momsSavings.withdraw(transferAmount);
harrysChecking.deposit(transferAmount);
```
And here is a program segment that adds interest to a savings account:
```
double interestRate = 5; // 5% interest
double interestAmount = momsSavings.getBalance() * interestRate / 100;
momsSavings.deposit(interestAmount);
```
				</text>
			</page>
			<page title="Static Methods">
				<text>
Java contains a Math class, which contains a collection of helpful methods for carrying out mathematical computations. These methods have a special form: they are static methods that do not operate on an object. That is, you don’t call
```
double root = 100.sqrt(); // Error
```
In Java, numbers are not objects, so you can never invoke a method on a number. Instead, you pass a number as an explicit parameter to a method, enclosing the number in parentheses after the method name:
```
double root = Math.sqrt(100);
```
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Methods/2.png</image>
				<text>
This call makes it appear as if the sqrt` method is applied to an object called Math. However, Math is a class, not an object. A method such as Math.sqrt that does not operate on any object is called a static method. (The term “static” is a historical holdover from the C and C++ programming languages. It has nothing to do with the usual meaning of the word.) In contrast, a method that is invoked on an object is class, is called an instance method:
```
harrysChecking.deposit(100); // deposit is an instance method
```
Static methods do not operate on objects, but they are still declared inside classes. When calling the method, you specify the class to which the sqrt method belongs—hence the call is Math.sqrt(100).

How can you tell that Math is a class and not an object? By convention, class names start with an uppercase letter (such as Math or BankAccount). Objects and methods start with a lowercase letter (such as harrysChecking and println). Therefore,
harrysChecking.deposit(100) denotes a call of the deposit method on the harrysChecking object inside the System class. On the other hand, Math.sqrt(100) denotes a call to the sqrt method inside the Math class.

This use of upper- and lowercase letters is merely a convention, not a rule of the Java language. It is, however, a convention that the authors of the Java class libraries follow consistently. You should do the same in your programs so that you don’t confuse your fellow programmers.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. Why can’t you call x.pow(y) to compute x^y?

2. Is the call System.out.println(4) a static method call?

				</text>
			</page>
			<page title="Overriding Methods">
				<text>
A subclass method overrides a superclass method if it has the same name and parameter types as a superclass method. When such a method is applied to a subclass object, the overriding method, and not the original method, is executed. We turn to the CheckingAccount class for an example of overriding methods. Recall that the BankAccount class has three methods:
```
public class BankAccount
{
	. . .
	public void deposit(double amount) { . . . } \\ this method overrides a BankAccount method
	public void withdraw(double amount) { . . . } \\ this method overrides a BankAccount method
	public double getBalance() { . . . }
}
```
The CheckingAccount class declares these methods:
```
public class CheckingAccount extends BankAccount
{
	. . .
	public void deposit(double amount) { . . . }
	public void withdraw(double amount) { . . . }
	public void deductFees() { . . . }
}
```
These methods override BankAccount methods.

The deposit and withdraw methods of the CheckingAccount class override the deposit and withdraw methods of the BankAccount class to handle transaction fees. However, the deductFees method does not override another method, and the getBalance method is not overridden.
				</text>
			</page>
			<page title="Overloaded Methods">
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Methods/5.png</image>
				<text>
Let’s implement the deposit method of the CheckingAccount class. It increments the transaction count and deposits the money:
```
public class CheckingAccount extends BankAccount
{
	. . .
	public void deposit(double amount)
	{
		transactionCount++;
		// Now add amount to balance
		. . .
	}
}
```
Now we have a problem. We can’t simply add amount to balance:
```
public class CheckingAccount extends BankAccount
{
	. . .
	public void deposit(double amount)
	{
		transactionCount++;
		// Now add amount to balance
		balance = balance + amount; // Error
	}
}
```
Although every CheckingAccount object has a balance instance variable, that instance variable is private to the superclass BankAccount. Subclass methods have no more access rights to the private data of the superclass than any other methods. If you
want to modify a private superclass instance variable, you must use a public method of the superclass.

How can we add the deposit amount to the balance, using the public interface of the BankAccount class? There is a perfectly good method for that purpose—namely, the deposit method of the BankAccount class. So we must invoke the deposit method on some object. On which object? The checking account into which the money is deposited—that is, the implicit parameter of the deposit method of the CheckingAccount class. To invoke another method on the implicit parameter, you don’t specify the parameter but simply write the method name, like this:
```
public class CheckingAccount extends BankAccount
{
	public void deposit(double amount)
	{
		transactionCount++;
		// Now add amount to balance
		deposit(amount); // Not complete
	}
	. . .
}
```
But this won’t quite work. The compiler interprets
```
deposit(amount);
```
as
```
this.deposit(amount);
```
The this parameter is of type CheckingAccount. There is a method called deposit in the CheckingAccount class. Therefore, that method will be called—but that is just the method we are currently writing! The method will call itself over and over, and the program will die in an infinite recursion. Instead, we must be specific that we want to invoke only the superclass’s deposit method. There is a special reserved word super for this purpose:
```
public class CheckingAccount extends BankAccount
{
	public void deposit(double amount)
	{
		transactionCount++;
		// Now add amount to balance
		super.deposit(amount);
	}
	. . .
}
```
This version of the deposit method is correct. To deposit money into a checking account, update the transaction count and call the deposit method of the superclass. The remaining methods of the CheckingAccount class also invoke a superclass method.
```
public class CheckingAccount extends BankAccount
{
	private static final int FREE_TRANSACTIONS = 3;
	private static final double TRANSACTION_FEE = 2.0;
	private int transactionCount;
	. . .
	public void withdraw(double amount)
	{
		transactionCount++;
		// Now subtract amount from balance
		super.withdraw(amount);
	}
	public void deductFees()
	{
		if (transactionCount > FREE_TRANSACTIONS)
		{
			double fees = TRANSACTION_FEE * (transactionCount - FREE_TRANSACTIONS);
			super.withdraw(fees);
		}
		transactionCount = 0;
	}
	. . .
}```
				</text>
			</page>
			<page title="Self Check">
				<text>
1. Categorize the methods of the SavingsAccount class as inherited, new, and overridden.

2. Why does the withdraw method of the CheckingAccount class call super.withdraw?

3. Why does the deductFees method set the transaction count to zero?
				</text>
			</page>
			<page title="Accidental Overloading">
				<text>
Recall from before that two methods can have the same name, provided they have different method parameters. For example, the PrintStream class has methods called println with headers
```
void println(int x)
```
and
```
void println(String x)
```
These are different methods, each with its own implementation. The Java compiler considers them to be completely unrelated. We say that the println name is overloaded. This is different from overriding, where a subclass method provides an implementation of a method with the same method parameters.

If you mean to override a method but supply a different parameter type, then you accidentally introduce an overloaded method. For example,
```
public class CheckingAccount extends BankAccount
{
	. . .
	public void deposit(int amount) // Error: should be double
	{
		. . .
	}
}
```
The compiler will not complain. It thinks that you want to provide a deposit method just for int parameters, while inheriting another deposit method for double parameters. When overriding a method, be sure to check that the parameter types match exactly.
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/input-output.png</image>
		<title>Input/Output</title>
		<description>Learn how to use scanners and become comfortable with input/output protocol</description>
		<pages>
			<page title="Introduction to Scanners">
				<text>
We begin this chapter by discussing the common task of reading and writing files that contain text. Examples are files that are created with a simple text editor, such as Windows Notepad, as well as Java source code and HTML files. The simplest mechanism for reading text is to use the Scanner class. You already know how to use a Scanner for reading console input. To read input from a disk file, the Scanner class relies on another class, File, which describes disk files and directories. (The File class has many methods that we do not discuss in this book; for example, methods that delete or rename a file.) First construct a File object with the name of the input file, then use the File to construct a Scanner object:
```
File inFile = new File("input.txt");
Scanner in = new Scanner(inFile);
```
This Scanner object reads text from the file input.txt. You can use the Scanner methods (such as next, nextLine, nextInt, and nextDouble) to read data from the input file. To write output to a file, you construct a PrintWriter object with the given file name, for example
```
PrintWriter out = new PrintWriter("output.txt");
```
If the output file already exists, it is emptied before the new data are written into it. If the file doesn’t exist, an empty file is created. You can also construct a PrintWriter object from a File object. This is useful if you use a file chooser.

The PrintWriter class is an enhancement of the PrintStream class that you already know—System.out is a PrintStream object. You can use the familiar print, println, and printf methods with any PrintWriter object:
```
out.print(29.95);
out.println(new Rectangle(5, 10, 15, 25));
out.printf("%10.2f", price);
```
When you are done writing to a file, be sure to close the PrintWriter:
```
out.close();
```
If your program exits without closing the PrintWriter, the disk file may not contain all of the output. The following program puts these concepts to work. It reads all lines of an input file and sends them to the output file, preceded by line numbers. If the input file is
```
Mary had a little lamb
Whose fleece was white as snow.
And everywhere that Mary went,
The lamb was sure to go!
```
then the program produces the output file
```
/* 1 */ Mary had a little lamb
/* 2 */ Whose fleece was white as snow.
/* 3 */ And everywhere that Mary went,
/* 4 */ The lamb was sure to go!
```
The line numbers are enclosed in /* */ delimiters so that the program can be used for numbering Java source files. There is one additional issue that we need to tackle. When the input or output file doesn’t exist, a FileNotFoundException can occur. The compiler insists that we tell it what the program should do when that happens. (In this regard, the `FileNotFoundException is different from the exceptions that you have already encountered. We will discuss this difference in detail later on.) In our sample program, we take the easy way out and acknowledge that the main method should simply be terminated if the exception occurs. We label the main method like this:
```
public static void main(String[] args) throws FileNotFoundException
```
You will see in the following sections how to deal with exceptions in a more professional way.
				</text>
			</page>
			<page title="Example Program">
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/InputOutput/2.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/InputOutput/3.png</image>
			</page>
			<page title="Self Check">
				<text>
1. What happens when you supply the same name for the input and output files to the LineNumberer program?

2. What happens when you supply the name of a nonexistent input file to the LineNumberer program?
				</text>
			</page>
			<page title="Common Errors">
				<text>
Common Error: Backslashes in File Names

When you specify a file name as a string literal, and the name contains backslash characters (as in a Windows file name), you must supply each backslash twice:
```
inFile = new File("c:\\homework\\input.dat");
```
Recall that a single backslash inside quoted strings is an escape character that is combined with another character to form a special meaning, such as \n for a newline character. The \\ combination denotes a single backslash. When a user supplies a file name to a program, however, the user should not type the backslash twice.

Common Error: Constructing a Scanner with a String

When you construct a PrintWriter with a string, it writes to a file:
```
PrintWriter out = new PrintWriter("output.txt");
```
However, this does not work for a Scanner. The statement
```
Scanner in = new Scanner("input.txt"); // ERROR?
```
does not open a file. Instead, it simply reads through the string: in.nextLine() returns the string "input.txt". This feature can be useful. You must simply remember to use File objects in the Scanner constructor:
```
Scanner in = new Scanner(new File("input.txt")); //OK
```
				</text>
			</page>
			<page title="Reading Text Input">
				<text>
In the following sections, you will learn how to process complex text input that you often encounter in real life situations. In the preceding example program, we read input a line at a time. Sometimes, it is useful to read words rather than lines. For example, consider the loop
```
while (in.hasNext())
{
	String input = in.next();
	System.out.println(input);
}
```
With our sample input, this loop would print a word on every line:
###
Mary
had
a
little
lamb
###
In Java, a word is not the same as in English. It is any sequence of characters that is not white space. White space includes spaces, tab characters, and the newline characters that separate lines. For example, the following are considered words:

snow.
1729
C++

(Note the period after snow—it is considered a part of the word because it is no white space.) Here is precisely what happens when the next method is executed. Input characters that are white space are consumed—that is, removed from the input. However, they do not become part of the word. The first character that is not white space becomes the first character of the word. More characters are added until either another white space character occurs, or the end of the input has been reached.

Sometimes, you want to read just the words and discard anything that isn’t a letter. You achieve this task by calling the useDelimiter method on your Scanner object as follows:
```
Scanner in = new Scanner(. . .);
in.useDelimiter("[^A-Za-z]+");
```
Here, we set the character pattern that separates words to “any sequence of characters other than letters”. (The notation used for describing the character pattern is called a regular expression.
				</text>
			</page>
			<page title="Processing Lines">
				<text>
When each line of a file is a data record, it is often best to read entire lines with the nextLine method:
```
String line = in.nextLine();
```
The nextLine method consumes the next input line (including the newline character) and returns the line without the newline character. You can then take the line apart for further processing. Here is a typical example of processing lines in a file. A file with population data from the CIA Fact Book site (http://www.cia.gov/library/publications/the-worldfactbook/) contains lines such as the following:
###
China 1330044605
India 1147995898
United States 303824646
. . .
###
Because some country names have more than one word, it would be tedious to read this file using the next method. For example, after reading United, how would your program know that it still needs to read another word before reading the population count? Instead, read each input line into a string. Then use the isDigit and isWhitespace methods to find out where the name ends and the number starts. Locate the first digit:
```
int i = 0;
while (!Character.isDigit(line.charAt(i))) { i++; }
```
Then extract the country name and population:
```
String countryName = line.substring(0, i);
String population = line.substring(i);
```
However, the country name contains one or more spaces at the end. Use the trim method to remove them:
```
countryName = countryName.trim();
```
The trim method returns the string with all white space at the beginning and end removed.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/InputOutput/9.png</image>
			</page>
			<page title="Processing Lines">
				<text>
There is another problem. The population is stored in a string, not a number. Use the Integer.parseInt method to convert it:
```
int populationValue = Integer.parseInt(population);
```
You need to be careful when calling the Integer.parseInt method. Its parameter value must be a string containing the digits of an integer or a NumberFormatException occurs. The parameter value may not contain any additional characters. Not even spaces are allowed! In our situation, we happen to know that there won’t be any spaces at the beginning of the string, but there might be some at the end. Therefore, we use the trim method:
```
int populationValue = Integer.parseInt(population.trim());
```
Here you saw how to break a string into parts by looking at individual characters. Another approach is occasionally easier. Construct a new Scanner object to read the characters from a string:
```
Scanner lineScanner = new Scanner(line);
```
Then you can use lineScanner like any other	Scanner	object, reading words and numbers:
```
String countryName = lineScanner.next();
while (!lineScanner.hasNextInt())
{
	countryName = countryName + " " + lineScanner.next();
}
int populationValue = lineScanner.nextInt();
```
				</text>
			</page>
			<page title="Reading Numbers">
				<text>
You have used the nextInt and nextDouble methods of the Scanner class many times, but here we will have a look at their behavior in detail. Suppose you call
```
double value = in.nextDouble();
```
The	nextDouble method recognizes floating-point numbers such as 3.14159, -21, or (a billion in scientific notation). However, if there is no number in the input, then a NoSuchElementException occurs. Consider an input containing the characters

				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/InputOutput/12.png</image>
				<text>

White space is consumed and the word 21st is read. However, this word is not a properly formatted number. In this situation, an “input mismatch exception” occurs.

To avoid exceptions, use the hasNextDouble method to screen the input. For example,
```
if (in.hasNextDouble())
{
	double value = in.nextDouble();
	. . .
}
```
Similarly, you should call the hasNextInt method before calling nextInt. Note that the nextInt and nextDouble methods do not consume the white space that follows a number. This can be a problem if you alternate between calling nextInt/nextDouble and nextLine. Suppose a file contains student IDs and names in this format:
###
1729
Harry Morgan
1730
Diana Lin
. . .
###
Now suppose you read the file with these instructions:
```
while (in.hasNextInt())
{
	int studentID = in.nextInt();
	String name = in.nextLine();

	//Process the student ID and name
}
```
Initially, the input contains

				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/InputOutput/14.png</image>
				<text>

After the first call to nextInt, the input contains

				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/InputOutput/16.png</image>
				<text>
The call to nextLine reads an empty string! The remedy is to add a call to nextLine after reading the ID:
```
int studentID = in.nextInt();
in.nextLine(); // Consume the newline
String name = in.nextLine();
```
				</text>
			</page>
			<page title="Reading Characters">
				<text>
Sometimes, you want to read a file one character at a time. You achieve this task by calling the useDelimiter method on your Scanner object with an empty string:
```
Scanner in = new Scanner(. . .);
in.useDelimiter("");
```
Now each call to next returns a string consisting of a single character. Here is how you can process the characters:
```
while (in.hasNext())
{
	char ch = in.next().charAt(0);
	// Process ch
}
```
				</text>
			</page>
			<page title="Self Check">
				<text>
1. Suppose the input contains the characters 6,995.0. What is the value of number and input after these statements?
```
int number = in.nextInt();
String input = in.next();
```
2. Suppose the input contains the characters 6,995.00 12. What is the value of price and quantity after these statements?
```
double price = in.nextDouble();
int quantity = in.nextInt();
```
3. Your input file contains a sequence of numbers, but sometimes a value is not available and marked as N/A. How can you read the numbers and skip over the markers?
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/comments.png</image>
		<title>Arrays</title>
		<description>Learn many new things about arrays</description>
		<pages>
			<page title="Introduction to Arrays">
				<text>
In many programs, you need to manipulate collections of related values. It would be impractical to use a sequence of variables such as value1, value2, value3, . . . , and so on. The array construct provides a better way of storing a collection of values. An array is a sequence of values of the same type. The values that are stored in an array are called its “elements”. For example, here is how you construct an array of 10 floating-point numbers:
```
new double[10]
```
The number of elements (here, 10) is called the length of the array. The new operator merely constructs the array. You will want to store a reference to the array in a variable so that you can access it later. The type of an array variable is the element type, followed by []. In this example, the type is double[], because the element type is double. Here is the declaration of an
array variable:
```
double[] values = new double[10];
```
That is, values is a reference to an array of floating-point numbers. It is initialized with an array of 10 numbers (see Figure 1).
You can also form arrays of objects, for example
```
BankAccount[] accounts = new BankAccount[10];
```
When an array is first created, all elements are initialized with 0 (for an array of numbers such as int[] or double[]), false (for a boolean[] array), or null (for an array of object references).
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/2.png</image>
				<text>
Alternatively, you can initialize an array with other values. List all elements that you want to include in the array, enclosed in braces and separated by commas:
```
int[] primes = { 2, 3, 5, 7, 11 };
```
The Java compiler counts how many elements you want to place in the array, allocates an array of the correct size, and fills it with the elements that you specify. Each element in the array is specified by an integer index that is placed inside square brackets ([]). For example, the expression
```
values[4]
```
denotes the element of the values array with index 4. You can store a value at a location with an assignment statement, such as the
following.
```
values[2] = 29.95;
```
Now the position with index 2 of values is filled with 29.95 (see Figure 2). To read the element at index 2, simply use the expression values[2] as you would any variable of type double:
```
System.out.println("The element at index 2 is " + values[2]);
```
If you look closely at Figure 2, you will notice that the index values start at 0. That is,

values[0] is the first element
values[1] is the second element
values[2] is the third element
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/4.png</image>
				<text>
and so on. This convention can be a source of grief for the newcomer, so you should pay close attention to the index values. In particular, the last element in the array has an index one less than the array length. For example, values refers to an array with
length 10. The last element is values[9]. If you try to access an element that does not exist, then an “array index out of
bounds” exception occurs. For example, the statement
```
values[10] = 29.95; // ERROR
```
is a bounds error.

To avoid bounds errors, you will want to know how many elements are in an array. The expression
```
values.length
```
is the length of the values array. Note that there are no parentheses following length—it is an instance variable of the array object, not a method. However, you cannot modify this instance variable. In other words, length is a final public instance variable. This is quite an anomaly. Normally, Java programmers use a method to inquire about the properties of an object. You just have to remember to
omit the parentheses in this case.

The following code ensures that you only access the array when the index variable i is within the legal bounds:
```
if (0 &lt;= i &amp;&amp; i &lt; values.length) values[i] = value;
```
Arrays suffer from a significant limitation: their length is fixed. If you start out with an array of 10 elements and later decide that you need to add additional elements, then you need to make a new array and copy all elements of the existing array into the new array. We will discuss this process in detail later.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/6.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/7.png</image>
			</page>
			<page title="Self Check">
				<text>
1. What elements does the values array contain after the following statements?
```
double[] values = new double[10];
for (int i = 0; i &lt; values.length; i++) values[i] = i * i;
```
2. What do the following program segments print? Or, if there is an error, describe the error and specify whether it is detected at compile-time or at run-time.
```
	a. double[] a = new double[10];
	   System.out.println(a[0]);
	b. double[] b = new double[10];
	   System.out.println(b[10]);
	c. double[] c;
	   System.out.println(c[0]);
```
				</text>
			</page>
			<page title="Bounds Errors">
				<text>
A very common array error is attempting to access a nonexistent position.
```
double[] data = new double[10];
data[10] = 29.95; // Error—only
```
have elements with index values 0 . . . 9

When the program runs, an out-of-bounds index generates an exception and terminates the program.

This is a great improvement over languages such as C and C++. With those languages there is no error message; instead, the program will quietly (or not so quietly) corrupt the memory location that is 10 elements away from the start of the array. Sometimes that corruption
goes unnoticed, but at other times, the program will act flaky or die a horrible death many instructions later. These are serious problems that make C and C++ programs difficult to debug. Bounds errors in C and C++ programs are a major cause of security vulnerabilities.
				</text>
			</page>
			<page title="Uninitialized and Unﬁlled Arrays">
				<text>
A common error is to allocate an array reference, but not an actual array.
```
double[] values;
values[0] = 29.95; // Error—values not initialized
```
Array variables work exactly like object variables—they are only references to the actual
array. To construct the actual array, you must use the new operator:
double[] values = new double[10];

Another common error is to allocate an array of objects and expect it to be filled with objects.
```
BankAccount[] accounts = new BankAccount[10]; // Contains ten null references
```
This array contains null references, not default bank accounts. You need to remember to fill
the array, for example:
```
for (int i = 0; i &lt; 10; i++)
{
accounts[i] = new BankAccount();
}
```
				</text>
			</page>
			<page title="Quality Tips">
				<text>
[H1]Use Arrays for Sequences of Related Values[H1]

Arrays are intended for storing sequences of values with the same meaning. For example, an
array of test scores makes perfect sense:
```
int[] scores = new int[NUMBER_OF_SCORES];
```
But it is a bad design to use an array
```
double[] personalData = new double[3];
```
that holds a person’s age, bank balance, and shoe size as personalData[0], personalData[1], and
personalData[2] . It would be tedious for the programmer to remember which of these data
items is stored in which array location. In this situation, it is far better to use three variables
```
int age;
double bankBalance;
double shoeSize;
```
[H1]Make Parallel Arrays into Arrays of Objects[H1]

Programmers who are familiar with arrays, but unfamiliar with object-oriented programming, sometimes distribute information across separate arrays. Here is a typical example. A
program needs to manage bank data, consisting of account numbers and balances. Don’t
store the account numbers and balances in separate arrays.
```
// Don’t do this
int[] accountNumbers;
double[] balances;
```
Arrays such as these are called parallel arrays (see Figure 3). The ith slice (accountNumbers[i]
and balances[i]) contains data that need to be processed together.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/12.png</image>
				<text>
If you find yourself using two arrays that have the same length, ask yourself whether you
couldn’t replace them with a single array of a class type. Look at a slice and find the concept
that it represents. Then make the concept into a class. In our example each slice contains an
account number and a balance, describing a bank account. Therefore, it is an easy matter to
use a single array of objects
```
BankAccount[] accounts;
```
(See Figure 4.)
Why is this beneficial? Think ahead. Maybe your program will change and you will need
to store the owner of the bank account as well. It is a simple matter to update the BankAccount
class. It may well be quite complicated to add a new array and make sure that all methods
that accessed the original two arrays now also correctly access the third one.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/14.png</image>
			</page>
			<page title="Special Topic">
				<text>
[H1]Methods with a Variable Number of Parameters[H1]
Starting with Java version 5.0, it is possible to declare methods that receive a variable number
of parameters. For example, we can modify the add method of the DataSet class of Chapter 6
so that one can add any number of values:
```
data.add(1, 3, 7);
data.add(4);
data.add(); // OK but not useful
```
The modified add method must be declared as
```
public void add(double... values)
```
The ... symbol indicates that the method can receive any number of double values. The xs
parameter is actually a double[] array that contains all values that were passed to the method.
The method implementation traverses the parameter array and processes the values:
```
public class DataSet
{
	. . .
	public void add(double... values)
	{
		for (int i = 0; i &lt; values.length; i++) // values is a double[]
		{
			double x = values[i];
			sum = sum + x;
			if (count == 0 || maximum &lt; x) maximum = x;
			count++;
		}
	}
}
```
				</text>
			</page>
			<page title="Array Lists">
				<text>
The array construct is rather primitive. In this section, we introduce the ArrayList
class. It lets you collect objects, just like an array does, but array lists offer two significant benefits:
• Array lists can grow and shrink as needed.
• The ArrayList class supplies methods for many common tasks, such as inserting
and removing elements.
You declare an array list of strings as follows:
```
ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();
```
The type ArrayList&lt;String&gt; denotes an array list of strings. The angle brackets
around the String type tell you that String is a type parameter. You can replace
String with any other class and get a different array list type. For that reason,
ArrayList is called a generic class. You will learn more about generic classes in
Chapter 17. For now, simply use an ArrayList&lt;T&gt; whenever you want to collect
objects of type T. However, keep in mind that you cannot use primitive types as
type parameters—there is no ArrayList&lt;int&gt; or ArrayList&lt;double&gt;. You will see in another section how to overcome that limitation.
When you construct an ArrayList object, it has size 0. You use the add method to
add an object to the end of the array list. The size increases after each call to add (see
Figure 5). The size method yields the current size of the array list.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/17.png</image>
				<text>
names.add("Emily"); // Now names has size 1 and element "Emily"
names.add("Bob"); // Now names has size 2 and elements "Emily", "Bob"
names.add("Cindy"); // names has size 3 and elements "Emily", "Bob", and "Cindy"

To obtain the value of an array list element, use the get method, not the [ ] operator.
As with arrays, index values start at 0. For example, names.get(2) retrieves the element with index 2, the third element in the array list:
```
String name = names.get(2);
```
As with arrays, it is an error to access a nonexistent element. A very common
bounds error is to use the following:
```
int i = names.size();
name = names.get(i); // Error
```
The last valid index is names.size() - 1.
To set an array list element to a new value, use the set method.
```
names.set(2, “Carolyn”);
```
This call sets position 2 of the names array list to "Carolyn", overwriting whatever
value was there before.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/19.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/20.png</image>
				<text>
The set method can only overwrite existing values. It is different from the add
method, which adds a new object to the end of the array list.
You can also insert an object in the middle of an array list. The call names.add(1,
“Ann”) moves all elements with index 1 or larger by one position and adds the string
“Ann” at index 1 (see Figure 6). After each call to the add method, the size of the array
list increases by 1.

Conversely, the remove method removes the element at a given index, moves all
elements after the removed element to the next lower index, and reduces the size of
the array list by 1. Part 3 of Figure 6 illustrates the call names.remove(1).
The following program demonstrates how to use ArrayList class for collecting
BankAccount objects. The BankAccount class has been enhanced from the version in
Chapter 3. Each bank account has an account number. Note that you import the
generic class java.util.ArrayList, without the type parameter.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/22.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/23.png</image>
			</page>
			<page title="Self Check">
				<text>
1. How do you construct an array of 10 strings? An array list of strings?

2. What is the content of names after the following statements?
```
ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();
names.add("A");
names.add(0, "B");
names.add("C");
names.remove(1);
```
				</text>
			</page>
			<page title="Wrappers and Auto-boxing">
				<text>
Because numbers are not objects in Java, you cannot directly insert them into array
lists. For example, you cannot form an ArrayList&lt;double&gt;. To store sequences of
numbers in an array list, you must turn them into objects by using wrapper classes.
There are wrapper classes for all eight primitive types:
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/26.png</image>
				<text>
Note that the wrapper class names start with uppercase letters, and that two of them
differ from the names of the corresponding primitive type: Integer and Character.
Each wrapper class object contains a value of the corresponding primitive type.
For example, an object of the class Double contains a value of type double (see
Figure 7).
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/28.png</image>
				<text>
Wrapper objects can be used anywhere that objects are required instead of primitive type values. For example, you can collect a sequence of floating-point numbers
in an ArrayList&lt;Double&gt;.

Conversion between primitive types and the corresponding wrapper classes is
automatic. This process is called auto-boxing (even though auto-wrapping would
have been more consistent).
For example, if you assign a number to a Double object, the number is automatically “put into a box”, namely a wrapper object.
```
Double d = 29.95; // Auto-boxing; same as Double d = new Double(29.95);
```
Conversely, wrapper objects are automatically “unboxed” to primitive types.
```
double x = d; // Auto-unboxing; same as double x = d.doubleValue();
```
Auto-boxing even works inside arithmetic expressions. For example, the statement
```
d = d + 1;
```
is perfectly legal. It means:
• Auto-unbox d into a double
• Add 1
• Auto-box the result into a new Double
• Store a reference to the newly created wrapper object in d
In order to collect numbers in an array list, simply remember to use the wrapper
type as the type parameter, and then rely on auto-boxing.
```
ArrayList&lt;Double&gt; values = new ArrayList&lt;Double&gt;();
values.add(29.95);
double x = values.get(0);
```
Keep in mind that storing wrapped numbers is quite inefficient. The use of wrappers is acceptable if you only collect a few numbers, but you should use arrays for
long sequences of numbers or characters.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. What is the difference between the types double and Double?

2. Suppose values is an ArrayList&lt;Double&gt; of size &gt; 0. How do you increment the
element with index 0?
				</text>
			</page>
			<page title="The Enhanced for Loop">
				<text>
Java version 5.0 introduces a very convenient shortcut for a common loop type.
Often, you need to iterate through a sequence of elements—such as the elements of
an array or array list. The enhanced for loop makes this process particularly easy to
program.

Suppose you want to total up all elements in an array values. Here is how you use
the enhanced for loop to carry out that task.
```
double[] values = . . .;
double sum = 0;
for (double element : values)
{
sum = sum + element;
}
```
The loop body is executed for each element in the array values. At the beginning of
each loop iteration, the next element is assigned to the variable element. Then the
loop body is executed. You should read this loop as “for each element in values”.
You may wonder why Java doesn’t let you write “for each (element in values)”.
Unquestionably, this would have been neater, and the Java language designers seriously considered this. However, the “for each” construct was added to Java several
years after its initial release. Had new reserved words each and in been added to the
language, then older programs that happened to use those identifiers as variable or
method names (such as System.in) would no longer have compiled correctly.
You don’t have to use the “for each” construct to loop through all elements in an
array. You can implement the same loop with a straightforward for loop and an
explicit index variable:
```
double[] values = . . .;
double sum = 0;
for (int i = 0; i &lt; values.length; i++)
{
double element = values[i];
sum = sum + element;
}
```
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/32.png</image>
				<text>
Note an important difference between the “for each” loop and the ordinary for
loop. In the “for each” loop, the loop variable e is assigned elements: values[0],
values[1], and so on. In the ordinary for loop, the loop variable i is assigned index
values: 0, 1, and so on.

You can also use the enhanced for loop to visit all elements of an array list. For
example, the following loop computes the total of the balances of all accounts:
```
ArrayList&lt;BankAccount&gt; accounts = . . . ;
double sum = 0;
for (BankAccount account : accounts)
{
	sum = sum + account.getBalance();
}
```
This loop is equivalent to the following ordinary for loop:
```
double sum = 0;
for (int i = 0; i &lt; accounts.size(); i++)
{
	BankAccount account = accounts.get(i);
	sum = sum + account.getBalance();
}
```
Keep in mind that the “for each” loop has a very specific purpose: getting the elements of a collection, from the beginning to the end. It is not suitable for all array
algorithms. In particular, the “for each” loop does not allow you to modify the contents of an array. The following loop does not fill an array with zeroes:
```
for (double element : values)
{
	element = 0; // ERROR—this assignment does not modify array elements
}
```
When the loop is executed, the variable element is first set to values[0]. Then element
is set to 0, then to values[1], then to 0, and so on. The values array is not modified.
The remedy is simple: Use an ordinary for loop
```
for (int i = 0; i &lt; values.length; i++)
{
	values[i] = 0; // OK
}
```
				</text>
			</page>
			<page title="Self Check">
				<text>
1. Write a “for each” loop that prints all elements in the array values.

2. What does this “for each” loop do?
```
int counter = 0;
for (BankAccount a : accounts)
{
	if (a.getBalance() == 0) { counter++; }
}
```
				</text>
			</page>
			<page title="Partially Filled Arrays">
				<text>
Suppose you write a program that reads a sequence of numbers into an array. How
many numbers will the user enter? You can’t very well ask the user to count the
items before entering them—that is just the kind of work that the user expects the

computer to do. Unfortunately, you now run into a problem. You need to set the
size of the array before you know how many elements you need. Once the array
size is set, it cannot be changed.
To solve this problem, make an array that is guaranteed to be larger than the largest possible number of entries, and partially fill it. For example, you can decide that
the user will never provide more than 100 input values. Then allocate an array of
size 100:
```
final int VALUES_LENGTH = 100;
double[] values = new double[VALUES_LENGTH];
```
Then keep a companion variable that tells how many elements in the array are actually used. It is an excellent idea always to name this companion variable by adding
the suffix Size to the name of the array.
```
int valuesSize = 0;
```
Now values.length is the capacity of the array values, and valuesSize is the current
size of the array (see Figure 8). Keep adding elements into the array, incrementing
the valuesSize variable each time.
```
values[valuesSize] = x;
valuesSize++;
```
This way, valuesSize always contains the correct element count.
The following code segment shows how to read numbers into a partially filled
array.
```
int valuesSize = 0;
Scanner in = new Scanner(System.in);
while (in.hasNextDouble())
{
	if (valuesSize &lt; values.length)
	{
		values[valuesSize] = in.nextDouble();
		valuesSize++;
	}
}
```
At the end of this loop, valuesSize contains the actual number of elements in the
array. Note that you have to stop accepting inputs if the valuesSize companion variable reaches the array length. Section 7.6 shows how you can overcome that limitation by growing the array.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/36.png</image>
				<text>
To process the gathered array elements, you again use the companion variable,
not the array length. This loop prints the partially filled array:
```
for (int i = 0; i &lt; valuesSize; i++)
{
	System.out.println(values[i]);
}
```
Array lists use this technique behind the scenes. An array list contains an array of
objects. When the array runs out of space, the array list allocates a larger array and
copies the elements. However, all of this happens inside the array list methods, so
you never need to think about it.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. Write a loop to print the elements of the partially filled array values in reverse
order, starting with the last element.

2. How do you remove the last element of the partially filled array values?

3. Why would a programmer use a partially filled array of numbers instead of an
array list?
				</text>
			</page>
			<page title="Common Array Algorithms">
				<text>
In the following sections, we discuss some of the most common algorithms for
working with arrays and array lists.
In the examples, we show a mixture of arrays and array lists so that you become
familiar with the syntax for both constructs.

[H1]Filling[H1]

This loop fills an array with zeroes:
```
for (int i = 0; i &lt; values.length; i++)
{
	values[i] = 0;
}
```
Here, we fill an array list with squares (0, 1, 4, 9, 16, …). Note that the element with
index 0 contains 02, the element with index 1 contains 12, and so on.
```
for (int i = 0; i &lt; values.size(); i++)
{
	values.set(i, i * i);
}
```
[H1]Computing Sum and Average Values[H1]

To compute the sum of all elements, simply keep a running total.
```
double total = 0;
for (double element : values)
{
	total = total + element;
}
```
To obtain the average, divide by the number of elements:
```
double average = total / values.size(); // For an array list
```
Be sure to check that the size is not zero.

[H1] Counting Matches[H1]

Suppose you want to find how many accounts of a certain type you have. Then you
must go through the entire collection and increment a counter each time you find a
match. Here we count the number of accounts whose balance is at least as much as a
given threshold:
```
public class Bank
{
	private ArrayList&lt;BankAccount&gt; accounts;
	public int count(double atLeast)
	{
		int matches = 0;
		for (BankAccount account : accounts)
		{
			if (account.getBalance() >= atLeast) matches++; // Found a match
		}
		return matches;
	}
	. . .
}
```
[H1]Finding the Maximum or Minimum[H1]

Suppose you want to find the account with the largest balance in the bank. Keep a
candidate for the maximum. If you find an element with a larger value, then replace
the candidate with that value. When you have reached the end of the sequence, you
have found the maximum.
There is just one problem. When you visit the starting element, you don’t yet
have a candidate for the maximum. One way to overcome that is to set the candidate to the starting element and make the first comparison with the next element.
```
BankAccount largestYet = accounts.get(0);
for (int i = 1; i &lt; accounts.size(); i++)
{
	BankAccount a = accounts.get(i);
	if (a.getBalance() > largestYet.getBalance())
	largestYet = a;
}
return largestYet;
```
Here we use an explicit for loop because the loop no longer visits all elements—it
skips the starting element.
Of course, this approach works only if there is at least one element. It doesn’t
make a lot of sense to ask for the largest element of an empty collection. We can
return null in that case:
```
if (accounts.size() == 0) return null;
BankAccount largestYet = accounts.get(0);
. . .
```
To compute the minimum of a data set, keep a candidate for the minimum and
replace it whenever you encounter a smaller value. At the end of the sequence, you
have found the minimum.

[H1]Searching for a Value[H1]

Suppose you want to know whether there is a bank account with a particular
account number in your bank. Simply inspect each element until you find a match
or reach the end of the sequence. Note that the loop might fail to find an answer,
namely if none of the accounts match. This search process is called a linear search.
```
public class Bank
{
	. . .
	public BankAccount find(int accountNumber)
	{
		for (BankAccount account : accounts)
		{
			if (account.getAccountNumber() == accountNumber) // Found a match
				return account;
		}
		return null; // No match in the entire array list
	}
	. . .
}
```
Note that the method returns null if no match is found.

[H1] Locating the Position of an Element[H1]

You often need to locate the position of an element so that you can replace or
remove it. Use a variation of the linear search algorithm, but remember the position
instead of the matching element. Here we locate the position of the first element
that is larger than 100.
```
int pos = 0;
boolean found = false;
while (pos &lt; values.size() &amp;&amp; !found)
{
	if (values.get(pos) > 100)
	{
		found = true;
	}
	else
	{
		pos++;
	}
}
if (found) { System.out.println("Position: " + pos); }
else { System.out.println("Not found"); }
```
[H1] Removing an Element[H1]

Removing an element from an array list is very easy—simply use the remove method.
With an array, you have to work harder.
Suppose you want to remove the element with index pos from the array values.
First off, you need to keep a companion variable for tracking the number of elements in the array, as explained in Section 7.5.
If the elements in the array are not in any particular order, simply overwrite the
element to be removed with the last element of the array, then decrement the variable tracking the size of the array. (See Figure 9.)
```
values[pos] = values[valuesSize - 1];
valuesSize--;
```
The situation is more complex if the order of the elements matters. Then you must
move all elements following the element to be removed to a lower index, and then
decrement the variable holding the size of the array. (See Figure 10.)
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Arrays/40.png</image>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/exceptions.png</image>
		<title>Exceptions</title>
		<description>Become comfortable with handling and throwing and catching and creating exceptions</description>
		<pages>
			<page title="Throwing Exceptions">
				<text>
There are two main aspects to exception handling: reporting and recovery. A major challenge of error handling is that the point of reporting is usually far apart from the point of recovery. For example, the get method of the ArrayList class may detect that a nonexistent element is being accessed, but it does not have enough information to decide what to do about this failure. Should the user be asked to try a different operation? Should the program be aborted after saving the user’s work? These decisions must be made in a different part of the program.

In Java, exception handling provides a flexible mechanism for passing control from the point of error reporting to a competent recovery handler. In the remainder of this chapter, we will look into the details of this mechanism.

When you detect an error condition, your job is really easy. You just throw an appropriate exception object, and you are done. For example, suppose someone tries to withdraw too much money from a bank account.
```
public class BankAccount
{
	. . .
	public void withdraw(double amount)
	{
		if (amount > balance)
		// Now what?
		. . .
	}
}
```
First look for an appropriate exception class. The Java library provides many classes to signal all sorts of exceptional conditions. Figure 1 on the next page shows the most useful ones.

Look around for an exception type that might describe your situation. How about the IllegalStateException? Is the bank account in an illegal state for the withdraw operation? Not really—some withdraw operations could succeed. Is the parameter value illegal? Indeed it is. It is just too large. Therefore, let’s throw an IllegalArgumentException. (The term argument is an alternative term for a parameter value.)
```
public class BankAccount
{
	public void withdraw(double amount)
	{
		if (amount > balance)
		{
			throw new IllegalArgumentException("Amount exceeds balance");
		}
		balance = balance - amount;
	}
	. . .
}
```
The statement
```
throw new IllegalArgumentException("Amount exceeds balance");
```
constructs an object of type IllegalArgumentException and throws that object.

When you throw an exception, execution does not continue with the next statement but with an exception handler. For now, we won’t worry about the handling of the exception.

				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Exceptions/2.png</image>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Exceptions/3.png</image>
			</page>
			<page title="Self Check">
				<text>
1. How should you modify the deposit method to ensure that the balance is never negative?

2. Suppose you construct a new bank account object with a zero balance and then call withdraw(10). What is the value of balance afterwards?
				</text>
			</page>
			<page title="Checked and Unchecked Exceptions">
				<text>
Java exceptions fall into two categories, called checked and unchecked exceptions. When you call a method that throws a checked exception, the compiler checks that you don’t ignore it. You must tell the compiler what you are going to do about the exception if it is ever thrown. For example, all subclasses of IOException are checked exceptions. On the other hand, the compiler does not require you to keep track of unchecked exceptions. Exceptions such as NumberFormatException, IllegalArgumentException, and NullPointerException are unchecked exceptions. More generally, all exceptions that belong to subclasses of RuntimeException are unchecked, and all other subclasses of the class Exception are checked. (In Figure 1, the checked exceptions are shaded in a darker color.) There is a second category of internal errors that are reported by throwing objects of type Error. One example is the OutOfMemoryError, which is thrown when all available memory has been used up. These are fatal errors that happen rarely and are beyond your control. They too are unchecked.

Why have two kinds of exceptions? A checked exception describes a problem that is likely to occur at times, no matter how careful you are. The unchecked exceptions, on the other hand, are your fault. For example, an unexpected end of file can be caused by forces beyond your control, such as a disk error or a broken network connection. But you are to blame for a NullPointerException, because your code was wrong when it tried to use a null reference. The compiler doesn’t check whether you handle a NullPointerException, because you should test your references for null before using them rather than install a handler for that exception. The compiler does insist that your program be able to handle error conditions that you cannot prevent.

Actually, those categories aren’t perfect. For example, the Scanner.nextInt method throws an unchecked InputMismatchException if the input does not contain a valid integer. A checked exception would have been more appropriate because the programmer cannot prevent users from entering incorrect input. (The designers of the Scanner class made this choice to make it easy to use for beginning programmers.)
As you can see from Figure 1, the majority of checked exceptions occur when you deal with input and output. That is a fertile ground for external failures beyond your control—a file might have been corrupted or removed, a network connection might be overloaded, a server might have crashed, and so on. Therefore, you will need to deal with checked exceptions principally when programming with files and
streams.

You have seen how to use the Scanner class to read data from a file, by passing a File object to the Scanner constructor:
```
String filename = . . .;
File inFile = new File(filename);
Scanner in = new Scanner(inFile);
```
However, the Scanner constructor can throw a FileNotFoundException. The FileNotFoundException is a checked exception, so you need to tell the compiler what you are going to do about it. You have two choices. You can handle the exception, using the techniques that you will see in Section 11.5. Or you can simply tell the compiler that you are aware of this exception and that you want your method to be
terminated when it occurs. The method that reads input does not usually know what to do about an unexpected error, so that is usually the better option.

To declare that a method should be terminated when a checked exception occurs within it, tag the method with a throws clause.
```
public void read(String filename) throws FileNotFoundException
{
	File inFile = new File(filename);
	Scanner in = new Scanner(inFile);
	. . .
}
```
The throws clause in turn signals the caller of your method that it may encounter a FileNotFoundException. Then the caller needs to make the same decision—handle the exception, or tell its caller that the exception may be thrown. If your method can throw exceptions of different types, you separate the exception class names by commas:
```
public void read(String filename)
throws FileNotFoundException, NoSuchElementException
```
Always keep in mind that exception classes form an inheritance hierarchy. For example, FileNotFoundException is a subclass of IOException. Thus, if a method can throw both an IOException and a FileNotFoundException, you only tag it as throws
IOException.

It sounds somehow irresponsible not to handle an exception when you know that it happened. Actually, though, it is usually best not to catch an exception if you don’t know how to remedy the situation. After all, what can you do in a low-level read method? Can you tell the user? How? By sending a message to System.out? You don’t know whether this method is called in a graphical program or an embedded
system (such as a vending machine), where the user may never see System.out. And even if your users can see your error message, how do you know that they can

				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Exceptions/6.png</image>
				<text>

understand English? Your class may be used to build an application for users in another country. If you can’t tell the user, can you patch up the data and keep going? How? If you set a variable to zero, null, or an empty string, that may just cause the program to break later, with much greater mystery. Of course, some methods in the program know how to communicate with the user or take other remedial action. By allowing the exception to reach those methods, you make it possible for the exception to be processed by a competent handler.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. Suppose a method calls the Scanner constructor, which can throw a FileNotFoundException, and the nextInt method of the Scanner class, which can cause a NoSuchElementException or InputMismatchException. Which exceptions should be included in the throws clause?

2. Why is a NullPointerException not a checked exception?
				</text>
			</page>
			<page title="Catching Exceptions">
				<text>
Every exception should be handled somewhere in your program. If an exception has no handler, an error message is printed, and your program terminates. That may be fine for a student program. But you would not want a professionally written program to die just because some method detected an unexpected error. Therefore, you should install exception handlers for all exceptions that your program might
throw.

You install an exception handler with the try/catch statement. Each try block contains one or more statements that may cause an exception. Each catch clause contains the handler for an exception type. Here is an example:
```
try
{
	String filename = . . .;
	File inFile = new File(filename);
	Scanner in = new Scanner(inFile);
	String input = in.next();
	int value = Integer.parseInt(input);
	. . .
}
catch (IOException exception)
{
	exception.printStackTrace();
}
catch (NumberFormatException exception)
{
	System.out.println("Input was not a number");
}
```
Three exceptions may be thrown in this try block: The Scanner constructor can throw a FileNotFoundException, Scanner.next can throw a NoSuchElementException, and Integer.parseInt can throw a NumberFormatException. If any of these exceptions is actually thrown, then the rest of the instructions in the try block are skipped. Here is what happens for the various exception types:

	• If a FileNotFoundException is thrown, then the catch clause for the IOException is executed. (Recall that FileNotFoundException is a subclass of IOException.)
	• If a NumberFormatException occurs, then the second catch clause is executed. 
	• A NoSuchElementException is not caught by any of the catch clauses. The exception remains thrown until it is caught by another try block or the main method terminates.

When the catch (IOException exception) block is executed, then some method in the try block has failed with an IOException. The variable exception contains a reference
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Exceptions/10.png</image>
				<text>
to the exception object that was thrown. The catch clause can analyze that object to find out more details about the failure. For example, you can get a printout of the chain of method calls that lead to the exception, by calling
```
exception.printStackTrace()
```
In these sample catch clauses, we merely inform the user of the source of the problem. A better way of dealing with the exception would be to give the user another chance to provide a correct input.

It is important to remember that you should place catch clauses only in methods in which you can competently handle the particular exception type.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. Suppose the file with the given file name exists and has no contents. Trace the flow of execution in the try block in this section.

2. Is there a difference between catching checked and unchecked exceptions?
				</text>
			</page>
			<page title="Designing Exception Types">
				<text>
Sometimes none of the standard exception types describe your particular error condition well enough. In that case, you can design your own exception class. Consider a bank account. Let’s report an InsufficientFundsException when an attempt is made to withdraw an amount from a bank account that exceeds the current balance.
```
if (amount > balance)
{
	throw new InsufficientFundsException(
	"withdrawal of " + amount + " exceeds balance of " + balance);
}
```
Now you need to provide the InsufficientFundsException class. Should it be a checked or an unchecked exception? Is it the fault of some external event, or is it the fault of the programmer? We take the position that the programmer could have prevented the exceptional condition—after all, it would have been an easy matter to check whether amount &lt;= account.getBalance() before calling the withdraw method.

Therefore, the exception should be an unchecked exception and extend the RuntimeException class or one of its subclasses.

It is a good idea to extend an appropriate class in the exception hierarchy. For example, we can consider an InsufficientFundsException a special case of an IllegalArgumentException. This enables other programmers to catch the exception as an IllegalArgumentException if they are not interested in the exact nature of the problem. It is customary to provide two constructors for an exception class: a constructor with no parameters and a constructor that accepts a message string describing the reason for the exception. Here is the declaration of the exception class.
```
public class InsufficientFundsException extends IllegalArgumentException
{
	public InsufficientFundsException() {}
	public InsufficientFundsException(String message)
	{
		super(message);
	}
}
```
When the exception is caught, its message string can be retrieved using the getMessage method of the Throwable class.
				</text>
			</page>
			<page title="Self Check">
				<text>
1. What is the purpose of the call super(message) in the second InsufficientFundsException constructor?

2. Suppose you read bank account data from a file. Contrary to your expectation, the next input value is not of type double. You decide to implement a BadDataException. Which exception class should you extend?
				</text>
			</page>
		</pages>
	</chapter>
	<chapter>
		<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Homepage/packages.png</image>
		<title>Packages</title>
		<description>Learn how packages can help you in Java land!</description>
		<pages>
			<page>
				<text>
A Java program consists of a collection of classes. So far, most of your programs have consisted of a small number of classes. As programs get larger, however, simply distributing the classes over multiple ﬁles isn’t enough. An additional structuring mechanism is needed.

In Java, packages provide this structuring mechanism. A Java package is a set of related classes. For example, the Java library consists of several hundred packages, some of which are listed in Table 1.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Packages/2.png</image>
			</page>
			<page title="Organizing Packages">
				<text>
To put one of your classes in a package, you must place a line package packageName; as the ﬁrst instruction in the source ﬁle containing the class. A package name consists of one or more identiﬁers separated by periods. For example, let’s put the Financial class introduced in this chapter into a package named com.horstmann.bigjava. The Financial.java ﬁle must start as follows:
```
package com.horstmann.bigjava;
public class Financial {   . . . }
```
In addition to the named packages (such as java.util or com.horstmann.bigjava), there is a special package, called the default package, which has no name. If you did not include any package statement at the top of your source ﬁle, its classes are placed
in the default package.
				</text>
				<image>https://res.cloudinary.com/ianspryn/image/upload/v1/Magis/Packages/4.png</image>
			</page>
			<page title="Importing Packages">
				<text>
If you want to use a class from a package, you can refer to it by its full name (package name plus class name). For example, java.util.Scanner refers to the Scanner class in the java.util package:
```
java.util.Scanner in = new java.util.Scanner(System.in);
```
Naturally, that is somewhat inconvenient. You can instead import a name with an import statement: import java.util.Scanner; Then you can refer to the class as Scanner without the package preﬁx. You can import all classes of a package with an import statement that ends in .*. For example, you can use the statement import java.util.*; to import all classes from the java.util package. That statement lets you refer to classes like Scanner or Random without a java.util preﬁx. However, you never need to import the classes in the java.lang package explicitly. That is the package containing the most basic Java classes, such as Math and Object. These classes are always available to you. In effect, an automatic import java.lang.*; statement has been placed into every source ﬁle. Finally, you don’t need to import other classes in the same package. For example, when you implement the class homework1.Tester, you don’t need to import the class homework1.Bank. The compiler will ﬁnd the Bank class without an import statement because it is located in the same
package, homework1.

Placing related classes into a package is clearly a convenient mechanism to organize classes. However, there is a more important reason for packages: to avoid name clashes. In a large project, it is inevitable that two people will come up with the same name for the same concept. This even happens in the standard Java class library (which has now grown to thousands of classes). There is a class Timer in the java.util package and another class called Timer in the javax.swing package. You can still tell the Java compiler exactly which Timer class you need, simply by referring to them as java.util.Timer and javax.swing.Timer.

Of course, for the package-naming convention to work, there must be some way to ensure that package names are unique. It wouldn’t be good if the car maker BMW placed all its Java code into the package bmw, and some other programmer (perhaps Britney M. Walters) had the same bright idea. To avoid this problem, the inventors of Java recommend that you use a package-naming scheme that takes advantage of the uniqueness of Internet domain names.

For example, I have a domain name horstmann.com, and there is nobody else on the planet with the same domain name. (I was lucky that the domain name horstmann.com had not been taken by anyone else when I applied. If your name is Walters, you will sadly ﬁnd that someone else beat you to  walters.com.) To get a package name, turn the domain name around to produce a package name preﬁx, such as com.horstmann.

If you don’t have your own domain name, you can still create a package name that has a high probability of being unique by writing your e-mail address backwards. For example, if Britney Walters has an e-mail address walters@cs.sjsu.edu, then she can use a package name
edu.sjsu.cs.walters for her own classes. Some instructors will want you to place each of your assignments into a separate package, such as homework1, homework2, and so on. The reason is again to avoid name collision. You can have two classes, homework1.Bank and Homework2.Bank, with slightly different properties.
				</text>
			</page>
		</pages>
	</chapter>
</lesson>